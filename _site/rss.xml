<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>Tumbler</title>
        <description>Tumbler - Zujin</description>
        <link>http://username.github.io</link>
        <atom:link href="http://username.github.io/rss.xml" rel="self" type="application/rss+xml" />
        <lastBuildDate>Tue, 24 Jan 2017 14:45:03 +0800</lastBuildDate>
        <pubDate>Tue, 24 Jan 2017 14:45:03 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>Spring Boot入门</title>
                <description>
</description>
                <link>http://username.github.io/2017/01/13/spring-boot</link>
                <guid>http://username.github.io/2017/01/13/spring-boot</guid>
                <pubDate>Fri, 13 Jan 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>WSGI理解</title>
                <description>
&lt;p&gt;&lt;strong&gt;What’s WSGI&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Web服务器网关接口(Python Web Server Gateway Interface，缩写为WSGI)是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。WSGI是作为Web服务器与Web应用程序或应用框架之间的一种低级别的接口，以提升可移植Web应用开发的共同点。WSGI是基于现存的CGI标准而设计的。&lt;/p&gt;

&lt;p&gt;WSGI区分为两个部份：一为“服务器”或“网关”，另一为“应用程序”或“应用框架”。在处理一个WSGI请求时，服务器会为应用程序提供环境资讯及一个回呼函数(Callback Function)。当应用程序完成处理请求后，透过前述的回呼函数，将结果回传给服务器。所谓的 WSGI 中间件同时实现了API的两方，因此可以在WSGI服务和WSGI应用之间起调解作用：从WSGI服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。“中间件”组件可以执行以下功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;重写环境变量后，根据目标URL，将请求消息路由到不同的应用对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;允许在一个进程中同时运行多个应用程序或应用框架。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;负载均衡和远程处理，通过在网络上转发请求和响应消息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进行内容后处理，例如应用XSLT样式表。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSGI没有官方的实现, 因为WSGI更像一个协议。只要遵照这些协议,WSGI应用(Application)都可以在任何服务器(Server)上运行, 反之亦然。WSGI就是Python的CGI包装，相对于Fastcgi是PHP的CGI包装。&lt;/p&gt;

&lt;p&gt;WSGI将 web 组件分为三类： web服务器，web中间件,web应用程序， wsgi基本处理模式为 ： WSGI Server -&amp;gt; (WSGI Middleware)* -&amp;gt; WSGI Application 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/wsgi.jpg&quot; alt=&quot;wsgi&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WSGI Server/gateway&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;wsgi server可以理解为一个符合wsgi规范的web server，接收request请求，封装一系列环境变量，按照wsgi规范调用注册的wsgi app，最后将response返回给客户端。文字很难解释清楚wsgi server到底是什么东西，以及做些什么事情，最直观的方式还是看wsgi server的实现代码。以python自带的wsgiref为例，wsgiref是按照wsgi规范实现的一个简单wsgi server。&lt;/p&gt;

&lt;p&gt;Python 2.5和更高版本带有一个WSGI服务器: wsgiref。&lt;/p&gt;

&lt;p&gt;大致流程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;服务器创建socket，监听端口，等待客户端连接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当有请求来时，服务器解析客户端信息放到环境变量environ中，并调用绑定的handler来处理请求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;handler解析这个http请求，将请求信息例如method，path等放到environ中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;wsgi handler再将一些服务器端信息也放到environ中，最后服务器信息，客户端信息，本次请求信息全部都保存到了环境变量environ中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;wsgi handler 调用注册的wsgi app，并将environ和回调函数传给wsgi app&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;wsgi app 将reponse header/status/body 回传给wsgi handler&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最终handler还是通过socket将response信息塞回给客户端。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Application Interface&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;WSGI应用程序接口被实现为callable对象：一个函数、一个方法、一个类或者一个实现了object.&lt;strong&gt;call&lt;/strong&gt;()方法的实例，这个callable对象必须能够：&lt;/p&gt;

&lt;p&gt;1.接受两个参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个包含类CGI变量的字典 environ&lt;/li&gt;
  &lt;li&gt;一个被应用用来发送HTTP状态码/信息和HTTP头部信息给服务器的回调函数 start_response&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.将响应内容以字符串迭代器的形式发给服务器&lt;/p&gt;

&lt;p&gt;应用程序的框架如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# The application interface is a callable object

# It accepts two arguments:
# environ points to a dictionary containing CGI like environment
# variables which is populated by the server for each
# received request from the client；
# start_response is a callback function supplied by the server
# which takes the HTTP status and headers as arguments
def application ( environ, start_response ):
    # Build the response body possibly
    # using the supplied environ dictionary
    response_body = &#39;Request method: %s&#39; % environ[&#39;REQUEST_METHOD&#39;]

    # HTTP response code and message
    status = &#39;200 OK&#39;

    # HTTP headers expected by the client
    # They must be wrapped as a list of tupled pairs:
    # [(Header name, Header value)].
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/plain&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]
  
    # Send them to the server using the supplied function
    start_response(status, response_headers)

    # Return the response body. Notice it is wrapped
    # in a list although it could be any iterable.
    return [response_body]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Enviroment Dict&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;服务器将来自客户端请求中的类似CGI的变量填充到环境变量字典中，下面脚本将输出整个字典：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python

# Python&#39;s bundled WSGI server
from wsgiref.simple_server import make_server

def application (environ, start_response):

    # Sorting and stringifying the environment key, value pairs
    response_body = [
        &#39;%s: %s&#39; % (key, value) for key, value in sorted(environ.items())
    ]
    response_body = &#39;\n&#39;.join(response_body)

    status = &#39;200 OK&#39;
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/plain&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]
    start_response(status, response_headers)

    return [response_body]

# Instantiate the server
httpd = make_server (
    &#39;localhost&#39;, # The host name
    8051, # A port number where to wait for the request
    application # The application object name, in this case a function
)

# Wait for a single request, serve it and quit
httpd.handle_request()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将上面程序片段保存为environment.py，在终端用运行：python environment.py，服务器将监听8051端口，打开浏览器输入：http://localhost:8051&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Apple_PubSub_Socket_Render: /private/tmp/com.apple.launchd.omVjTfSPWb/Render
COLORFGBG: 7;0
CONTENT_LENGTH: 
CONTENT_TYPE: text/plain
GATEWAY_INTERFACE: CGI/1.1
HOME: /Users/yuzujin
HTTP_ACCEPT: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
HTTP_ACCEPT_ENCODING: gzip, deflate, sdch, br
HTTP_ACCEPT_LANGUAGE: zh-CN,zh;q=0.8,en;q=0.6,pt;q=0.4,th;q=0.2,ar;q=0.2,ja;q=0.2
HTTP_CONNECTION: keep-alive
HTTP_HOST: localhost:8051
HTTP_UPGRADE_INSECURE_REQUESTS: 1
HTTP_USER_AGENT: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36
ITERM_PROFILE: Default
ITERM_SESSION_ID: w0t4p0:B9A76F07-EEF7-495A-8CC6-ECAA412ADBB0
LANG: zh_CN.UTF-8
LC_CTYPE: zh_CN.UTF-8
LESS: -R
LOGNAME: yuzujin
LSCOLORS: Gxfxcxdxbxegedabagaacd
OLDPWD: /Users/yuzujin/app/test/static/font
PAGER: less
PATH: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
PATH_INFO: /
PWD: /Users/yuzujin/app
QUERY_STRING: 
REMOTE_ADDR: 127.0.0.1
REMOTE_HOST: 1.0.0.127.in-addr.arpa
REQUEST_METHOD: GET
SCRIPT_NAME: 
SERVER_NAME: 1.0.0.127.in-addr.arpa
SERVER_PORT: 8051
SERVER_PROTOCOL: HTTP/1.1
SERVER_SOFTWARE: WSGIServer/0.1 Python/2.7.6
SHELL: /bin/zsh
SHLVL: 1
SSH_AUTH_SOCK: /private/tmp/com.apple.launchd.itL8Kal1Y1/Listeners
TERM: xterm-256color
TERM_PROGRAM: iTerm.app
TERM_PROGRAM_VERSION: 3.0.12
TERM_SESSION_ID: w0t4p0:B9A76F07-EEF7-495A-8CC6-ECAA412ADBB0
TMPDIR: /var/folders/2k/yqr8f64n66j1q_ydgf6phb9h0000gn/T/
USER: yuzujin
VERSIONER_PYTHON_PREFER_32_BIT: no
VERSIONER_PYTHON_VERSION: 2.7
XPC_FLAGS: 0x0
XPC_SERVICE_NAME: 0
ZSH: /Users/yuzujin/.oh-my-zsh
_: /usr/bin/python
__CF_USER_TEXT_ENCODING: 0x1F5:0x19:0x34
wsgi.errors: &amp;lt;open file &#39;&amp;lt;stderr&amp;gt;&#39;, mode &#39;w&#39; at 0x106c721e0&amp;gt;
wsgi.file_wrapper: wsgiref.util.FileWrapper
wsgi.input: &amp;lt;socket._fileobject object at 0x106d7a450&amp;gt;
wsgi.multiprocess: False
wsgi.multithread: True
wsgi.run_once: False
wsgi.url_scheme: http
wsgi.version: (1, 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Response Iterable&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;WSGI 应用的返回是return [response_body]，如果换成return response_body，会发生什么呢？
服务器将生成一个字节迭代器，一次向客户端只发送一个字节，这样速度很慢，而return [response_body]是生成一个字符串迭代器，效率高很多。&lt;/p&gt;

&lt;p&gt;如果迭代器yield多个字符串，则响应主体的长度将是所有字符串长度之和，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python

from wsgiref.simple_server import make_server

def application(environ, start_response):

    response_body = [
        &#39;%s: %s&#39; % (key, value) for key, value in sorted(environ.items())
    ]
    response_body = &#39;\n&#39;.join(response_body)

    # Adding strings to the response body
    response_body = [
        &#39;The Beggining\n&#39;,
        &#39;*&#39; * 30 + &#39;\n&#39;,
        response_body,
        &#39;\n&#39; + &#39;*&#39; * 30 ,
        &#39;\nThe End&#39;
    ]

    # So the content-lenght is the sum of all string&#39;s lengths
    content_length = sum([len(s) for s in response_body])

    status = &#39;200 OK&#39;
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/plain&#39;),
        (&#39;Content-Length&#39;, str(content_length))
    ]

    start_response(status, response_headers)
    return response_body

httpd = make_server(&#39;localhost&#39;, 8051, application)
httpd.handle_request()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;WSGI请求解析&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;1.GET方式&lt;/p&gt;

&lt;p&gt;GET方式下，query string就是?之后的所有内容。&lt;/p&gt;

&lt;p&gt;例如请求为：http://localhost:8051/?age=10&amp;amp;hobbies=software&amp;amp;hobbies=tunning&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

from wsgiref.simple_server import make_server
from cgi import parse_qs, escape

html = &quot;age: %(age)s software: %(checked-software)s tunning: %(checked-software)s hobbies: %(hobbies)s&quot;
          
def application (environ, start_response):

    # Returns a dictionary in which the values are lists
    d = parse_qs(environ[&#39;QUERY_STRING&#39;])

    # As there can be more than one value for a variable then
    # a list is provided as a default value.
    age = d.get(&#39;age&#39;, [&#39;&#39;])[0] # Returns the first age value
    hobbies = d.get(&#39;hobbies&#39;, []) # Returns a list of hobbies

    # Always escape user input to avoid script injection
    age = escape(age)
    hobbies = [escape(hobby) for hobby in hobbies]

    response_body = html % { # Fill the above html template in
        &#39;checked-software&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;software&#39; in hobbies],
        &#39;checked-tunning&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;tunning&#39; in hobbies],
        &#39;age&#39;: age or &#39;Empty&#39;,
        &#39;hobbies&#39;: &#39;, &#39;.join(hobbies or [&#39;No Hobbies?&#39;])
    }

    status = &#39;200 OK&#39;

    # Now content type is text/html
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/html&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]

    start_response(status, response_headers)
    return [response_body]

httpd = make_server(&#39;localhost&#39;, 8051, application)

# Now it is serve_forever() in instead of handle_request()
httpd.serve_forever()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.POST方式&lt;/p&gt;

&lt;p&gt;POST方式下，query string不是在url中传递的，而是在HTTP请求体中，WSGI server提供了wsgi.input文件获取环境变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python

from wsgiref.simple_server import make_server
from cgi import parse_qs, escape

html = &quot;age: %(age)s software: %(checked-software)s tunning: %(checked-software)s hobbies: %(hobbies)s&quot;
    
def application(environ, start_response):

    # the environment variable CONTENT_LENGTH may be empty or missing
    try:
        request_body_size = int(environ.get(&#39;CONTENT_LENGTH&#39;, 0))
    except (ValueError):
        request_body_size = 0

    # When the method is POST the variable will be sent
    # in the HTTP request body which is passed by the WSGI server
    # in the file like wsgi.input environment variable.
    request_body = environ[&#39;wsgi.input&#39;].read(request_body_size)
    d = parse_qs(request_body)

    age = d.get(&#39;age&#39;, [&#39;&#39;])[0] # Returns the first age value.
    hobbies = d.get(&#39;hobbies&#39;, []) # Returns a list of hobbies.

    # Always escape user input to avoid script injection
    age = escape(age)
    hobbies = [escape(hobby) for hobby in hobbies]

    response_body = html % { # Fill the above html template in
        &#39;checked-software&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;software&#39; in hobbies],
        &#39;checked-tunning&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;tunning&#39; in hobbies],
        &#39;age&#39;: age or &#39;Empty&#39;,
        &#39;hobbies&#39;: &#39;, &#39;.join(hobbies or [&#39;No Hobbies?&#39;])
    }

    status = &#39;200 OK&#39;

    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/html&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]

    start_response(status, response_headers)
    return [response_body]

httpd = make_server(&#39;localhost&#39;, 8051, application)
httpd.serve_forever()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;WSGI 应用框架&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;appier&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Appier is an object-oriented Python web framework built for super fast app development. It’s as lightweight as possible, but not too lightweight. It gives you the power of bigger frameworks, without their complexity.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bobo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bobo is a light-weight framework. Its goal is to be easy to use and remember.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bottle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bottle is a fast and simple micro-framework for small web-applications. It offers request dispatching (Routes) with url parameter support, Templates, key/value Databases, a build-in HTTP Server and adapters for many third party WSGI/HTTP-server and template engines. All in a single file and with no dependencies other than the Python Standard Library.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CherryPy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CherryPy is a pythonic, object-oriented web development framework. Includes support for WSGI servers. CherryPy 3 includes better support for living alongside other WSGI frameworks, applications, and middleware.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Django&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Includes support for WSGI servers&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Falcon&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Falcon is a high-performance Python framework for building cloud APIs. It encourages the REST architectural style, and tries to do as little as possible while remaining highly effective.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Flask&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions.&lt;/p&gt;

&lt;p&gt;It inherits its high WSGI usage and compliance from Werkzeug.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;notmm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The notmm toolkit is a fork of Django that doesn’t get in your way. Features includes improved WSGI support (Paste), SQLAlchemy, and very few developers! ;-)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PoorWSGI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Poor WSGI for Python is light WGI connector with uri routing between WSGI server and your application. It have mod_python compatible request object, which is post to all uri or http state handler.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pycnic&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pycnic is a mimimalist JSON API oriented framework for Python 2.7 and 3.x. It provides routing, cookies, and JSON error handling, while maintaining a small codebase.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pyramid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Merger of the Pylons and repoze.bfg projects, Pyramid is a minimalist web framework aiming at composability and making developers paying only for what they use.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;QWeb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another WSGI framework (not sure what the distinguishing features are)
repoze.zope2
A module that implements an analogue of the Zope 2 ZPublisher, with some major simplifications and cleanups. Its core mission is to allow publishing existing Zope2 applications in a WSGI environment that externalizes some of the features of “classic” Zope2 into middleware.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TurboGears&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Database-driven app in minutes; inherits its WSGI support from CherryPy.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;web.py&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Makes web apps. A small RESTful library.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;web2py&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A full stack framework includes its own Database Abstraction Layer (with support for SQLite, MySQL, PostgreSQL, MSSQL, DB2, Informix, Oracle, FireBase, Ingres and Google App Engine), its own template laguage, and a web based IDE. web2py itself is a WSGI app. Not related to web.py.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WebCore&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A nanoframework (only a few hundred lines of code) offering an entry_points-based dependency graphing extension system, MVC separation, reusable namespaces, and universal URL dispatch protocol with tight WebOb integration and natural Python semantics.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;weblayer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;weblayer is a lightweight, componentised package for writing WSGI applications.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Zope 3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The venerable Python web framework, recreated anew in Zope 3, and now a WSGI application. It seems to have some WSGI bits deep inside the publisher, but they aren’t really documented at this time.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WSGI 服务器&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;ajp-wsgi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A threaded/forking WSGI server implemented in C (it embeds a Python interpreter to run the actual application). It communicates with the web server via AJP, and is known to work with mod_jk and mod_proxy_ajp. Also available in an SCGI flavor.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Aspen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A pure-Python web server (using the CherryPy module mentioned next) with three hooks to hang your WSGI on.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cherrypy.wsgiserver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CherryPy’s “high-speed, production ready, thread pooled, generic WSGI server.” Includes SSL support. Supports Transfer-Encoding: chunked. For details on running foreign (non-CherryPy) applications under the CherryPy WSGI server, see WSGI Support. See also the CherryPy wiki ModWSGI page.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;chiral.web.httpd&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A fast HTTP server supporting WSGI, with extensions for Coroutine-based pages with deeply-integrated COMET support.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cogen.web.wsgi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSGI server with extensions for coroutine oriented programming.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FAPWS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fapws is a WSGI binding between Python and libev.&lt;/p&gt;

&lt;p&gt;See also: author’s block, GoogleGroup.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fcgiapp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fcgiapp is a Python wrapper for the C FastCGI SDK. It’s used by PEAK’s FastCGI servers to provide WSGI-over-FastCGI.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;flup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Includes threaded and forking versions of servers that support FastCGI, SCGI, and AJP protocols.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gevent-fastcgi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSGI-over-FastCGI server implemented using gevent coroutine-based networking library. Supports FastCGI connection multiplexing. Includes adapters for Django and other frameworks that use PasteDeploy.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gunicorn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSGI HTTP Server for UNIX, fast clients and nothing else. This is a port of Unicorn to Python and WSGI.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ISAPI-WSGI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An implementation of WSGI for running as a ISAPI extension under IIS.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;James&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;James provides a very simple multi-threaded WSGI server implementation based on the HTTPServer from Python’s standard library. (unmaintained)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Julep&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A WSGI Server inspired by Unicorn, written in pure Python.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;m2twisted&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSGI server built with M2Crypto and twisted.web2 with some SSL related tricks. Used with client side smart cards and it is also possible to run the HTTPS server with a key in a HSM (like a crypto token)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;modjy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Modjy is a java servlets to WSGI gateway that enables the running of jython WSGI applications inside java servlet containers.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mod_wsgi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python WSGI adapter module for Apache&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NWSGI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NWSGI is a .NET implementation of the Python WSGI specification for IronPython and IIS. This makes it easy to run Python web applications on Windows Server. This is a potential alternative to ISAPI + ISAPI_WSGI modules.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;netius&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Netius is a Python network library that can be used for the rapid creation of asynchronous non-blocking servers and clients. It has no dependencies, it’s cross-platform, and brings some sample netius-powered servers out of the box, namely a production-ready WSGI server.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;paste.httpserver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Minimalistic threaded WSGI server built on BaseHTTPServer. Doesn’t support Transfer-Encoding: chunked.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;phusion passenger&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;“proof of concept” WSGI since 2008 (1.x), support upgraded to “beta” in version 3 (with limitations e.g. requires Ruby even when unused) and first-class in Passenger 4.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;python-fastcgi&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;python-fastcgi is a lightweight wrapper around the Open Market FastCGI C Library/SDK. It includes threaded and forking WSGI server implementations.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Spawning&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;twisted.web&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A WSGI server based on Twisted Web’s HTTP server (requires Twisted 8.2 or later).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;uWSGI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fast, self-healing, developer-friendly WSGI server, meant for professional deployment and development of Python Web applications.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;werkzeug.serving&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Werkzeug’s multithreaded and multiprocessed development server. Wraps wsgiref to add a reloader, multiprocessing, static files handling and SSL.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;wsgid&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Wsgid is a generic WSGI handler for mongrel2 webserver. Wsgid offers a complete daemon environment (start/stop/restart) to your app workers, including automatically re-spawning of processes.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WSGIserver&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSGIserver is a high-speed, production ready, thread pooled, generic WSGI server with SSL support for both Python 2 (2.6 and above) and Python 3 (3.1 and above). WSGIserver is a one file project with no dependency.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WSGIUtils&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Includes a threaded HTTP server.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;wsgiref (Python 3)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Included as part of thef standard library since Python 2.5; it includes a threaded HTTP server, a CGI server (for running any WSGI application as a CGI script), and a framework for building other servers.&lt;/p&gt;

&lt;p&gt;For versions prior to Python 2.5, see wsgiref’s original home.&lt;/p&gt;

</description>
                <link>http://username.github.io/2017/01/10/wsgi</link>
                <guid>http://username.github.io/2017/01/10/wsgi</guid>
                <pubDate>Tue, 10 Jan 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>CGI的前世今生</title>
                <description>
&lt;p&gt;&lt;strong&gt;CGI&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;CGI (Common Gateway Interface) 是外部应用程序（CGI程序）与 WEB 服务器之间的接口标准（协议），是在CGI程序和Web服务器之间传递信息的过程。CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI 将 Web 的一组简单的静态超媒体文档变成一个完整的新的交互式媒体。&lt;/p&gt;

&lt;p&gt;最初，CGI 是在 1993 年由美国国家超级电脑应用中心（NCSA）为 NCSA HTTPd Web 服务器开发的。&lt;/p&gt;

&lt;p&gt;这个 Web 服务器使用了 UNIX shell 环境变量来保存从 Web 服务器传递出去的参数，然后生成一个运行 CGI 的独立进程。CGI的第一个实现是 Perl 写的。&lt;/p&gt;

&lt;p&gt;对一个 CGI 程序，做的工作其实只有：从环境变量(environment variables)和标准输入(standard input)中读取数据、处理数据、向标准输出(standard output)输出数据。&lt;/p&gt;

&lt;p&gt;环境变量中存储的叫 Request Meta-Variables，也就是诸如 QUERY_STRING、PATH_INFO 之类的东西，这些是由 Web Server 通过环境变量传递给 CGI 程序的，CGI 程序也是从环境变量中读取的。标准输入中存放的往往是用户通过 PUTS 或者 POST 提交的数据，这些数据也是由 Web Server 传过来的。&lt;/p&gt;

&lt;p&gt;环境变量列表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SERVER_NAME&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;运行CGI序为机器名或IP地址。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SERVER_INTERFACE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;WWW服务器的类型，如：CERN型或NCSA型。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SERVER_PROTOCOL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;通信协议，应当是HTTP/1.0。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SERVER_PORT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TCP端口，一般说来web端口是80。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP_ACCEPT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP定义的浏览器能够接受的数据类型。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP_REFERER&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;发送表单的文件URL。（并非所有的浏览器都传送这一变量）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP_USER-AGENT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;发送表单的浏览的有关信息。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GETWAY_INTERFACE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CGI程序的版本，在UNIX下为 CGI/1.1。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PATH_TRANSLATED&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PATH_INFO中包含的实际路径名。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PATH_INFO&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;浏览器用GET方式发送数据时的附加路径。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SCRIPT_NAME&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CGI程序的路径名。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;QUERY_STRING&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表单输入的数据，URL中问号后的内容。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;REMOTE_HOST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;发送程序的主机名，不能确定该值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;REMOTE_ADDR&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;发送程序的机器的IP地址。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;REMOTE_USER&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;发送程序的人名。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CONTENT_TYPE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST发送，一般为application/xwww-form-urlencoded。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CONTENT_LENGTH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST方法输入的数据的字节数。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CGI 的缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;效率低下：每一个连接 fork 一个进程处理。&lt;/li&gt;
  &lt;li&gt;功能十分有限：CGI只能收到一个请求，输出一个响应。很难在 CGI 体系去对Web请求的控制，例如：用户认证等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;FastCGI&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;FastCGI (Fast Common Gateway Interface) 是一种让交互程序与 Web Server 通信的协议。FastCGI 是 CGI 的增强版本。 FastCGI 致力于减少 WebServer 与 CGI 程序之间互动的开销，从而使 Web Server 可以同时处理更多的请求。&lt;/p&gt;

&lt;p&gt;不同于 CGI 为每一个请求创建一个进程，FastCGI 维护一个进程池用来处理持续不断的请求，这些进程是由FastCGI 管理，而不是Web Server。Fastcgi 先fork一个master，解析配置文件，初始化执行环境，然后再fork多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是Fastcgi的对进程的管理。&lt;/p&gt;

&lt;p&gt;Web Server 是通过 Unix domain socket、命名管道(Name pipe)或者 TCP 链接来向一个FastCGI 进程发送环境变量信息和请求本身的。请求的响应内容以同样的方式返回给 Web Server，Web Server 随后将响应发给客户端。这个链接在响应完成后可能会被关闭，但是web server 和 FastCGI 进程都会被保留。&lt;/p&gt;

&lt;p&gt;使用FastCGI 的 Web Server&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Apache HTTP Server (部分)&lt;/p&gt;

    &lt;p&gt;通过mod_fcgid模块实现，这个模块曾属于第三方，后来成为Apache的一个子项目，这个模块仅支持Unix 套接字，不支持TCP套接字。&lt;/p&gt;

    &lt;p&gt;一个较早的第三方模块mod_fcgi也还在用。
从Apache 2.4开始，mod_proxy_fcgi被加进来，为了支持TCP FastCGI servers。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Cherokee HTTP Server&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hiawatha Webserver（英语：Hiawatha_(web_server)）&lt;/p&gt;

    &lt;p&gt;支持FastCGI的負載平衡&lt;/p&gt;

    &lt;p&gt;支持chrooted FastCGI 伺服器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Lighttpd&lt;/li&gt;
  &lt;li&gt;Nginx&lt;/li&gt;
  &lt;li&gt;LiteSpeed Web Server&lt;/li&gt;
  &lt;li&gt;Microsoft IIS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;PHP-CGI&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;php-cgi 是一种CGI 协议的实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;php-cgi 其实就是PHP 解析器。&lt;/li&gt;
  &lt;li&gt;在CGI 模式时，当Web Server 收到 xx/index.php 请求时，会启动php-cgi，php-cgi 会解析php.ini 文件，初始化环境，然后根据请求参数进行处理，再返回处理后的结果。(都是以CGI 协议规范来进行)&lt;/li&gt;
  &lt;li&gt;php-cgi 在每个请求时都会启动一个进程，然后读取php.ini 进行解析，可想而知效率相对比较低。&lt;/li&gt;
  &lt;li&gt;php-cgi 无法实现平滑重启。修改php.ini 配置后，后面启动的php-cgi 程序还是不会感知。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;PHP-FPM&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;FastCGI Process Management，是一种FastCGI 协议的实现。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当请求到来时，php-fpm 启动并读取php.ini 文件完成初始化环境，然后启动一个master，再启动多个worker。当请求过来时，master 会传递给一个worker，然后等待下一个请求。php-fpm 会动态配置worker 的数量。&lt;/li&gt;
  &lt;li&gt;一个php-fpm 进程可以处理多个请求，会启动多个php-cgi 程序。&lt;/li&gt;
  &lt;li&gt;php-fpm 可以实现平衡重启。修改php.ini 后，当启用新的worker 会使用新的配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;spawn-fcgi&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Spawn-FCGI是一个通用的FastCGI管理服务器，它是lighttpd中的一部份，很多人都用Lighttpd的Spawn-FCGI进行 FastCGI模式下的管理工作，不过有不少缺点。而PHP-FPM的出现多少缓解了一些问题，但PHP-FPM有个缺点就是要重新编译，这对于一些已经运行的环境可能有不小的风险(refer)，在php5.3.3中可以直接使用PHP-FPM了。&lt;/p&gt;

&lt;p&gt;Spawn-FCGI目前已经独成为一个项目，更加稳定一些，也给很多Web站点的配置带来便利。已经有不少站点将它与nginx搭配来解决动态网页。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spawn-fcgi -a 127.0.0.1 -p9000 -C5 -u www-data -g www-data -f /usr/bin/php-CGI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数含义如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-f 指定调用FastCGI的进程的执行程序位置，根据系统上所装的PHP的情况具体设置&lt;/li&gt;
  &lt;li&gt;-a 绑定到地址addr&lt;/li&gt;
  &lt;li&gt;-p 绑定到端口port&lt;/li&gt;
  &lt;li&gt;-s 绑定到unix socket的路径path&lt;/li&gt;
  &lt;li&gt;-C 指定产生的FastCGI的进程数，默认为5(仅用于PHP)&lt;/li&gt;
  &lt;li&gt;-P 指定产生的进程的PID文件路径&lt;/li&gt;
  &lt;li&gt;-u和-g FastCGI使用什么身份(-u 用户 -g用户组)运行，Ubuntu下可以使用www-data，其他的根据情况配置，如nobody、apache等&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://username.github.io/2017/01/08/cgi</link>
                <guid>http://username.github.io/2017/01/08/cgi</guid>
                <pubDate>Sun, 08 Jan 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>MongoDB集群分片</title>
                <description>
&lt;p&gt;MongoDB副本集有两个问题没有解决：从节点每个上面的数据都是对数据库全量拷贝，从节点压力会不会过大；数据压力大到机器支撑不了的时候不能做到自动扩展。&lt;/p&gt;

&lt;p&gt;处理海量数据时，传统数据库是在数据库层之上增加一个数据访问层组件，它主要的作用是SQL解析、路由处理。根据应用的请求的功能解析当前访问的sql判断是在哪个业务数据库、哪个表访问查询并返回数据结果。数据库的增加、删除、备份需要程序去控制。&lt;/p&gt;

&lt;p&gt;MongoDB所有的这一切通过他自己的内部机制就可以搞定：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo15.jpg?raw=true&quot; alt=&quot;mongo15&quot; title=&quot;Title&amp;quot; &amp;quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到有四个组件：mongos、config server、shard、replica set。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;mongos&lt;/code&gt;，数据库集群请求的入口，所有的请求都通过mongos进行协调，不需要在应用程序添加一个路由选择器，mongos自己就是一个请求分发中心，它负责把对应的数据请求请求转发到对应的shard服务器上。在生产环境通常有多mongos作为请求的入口，防止其中一个挂掉所有的mongodb请求都没有办法操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;config server&lt;/code&gt;，顾名思义为配置服务器，存储所有数据库元信息（路由、分片）的配置。mongos本身没有物理存储分片服务器和数据路由信息，只是缓存在内存里，配置服务器则实际存储这些数据。mongos第一次启动或者关掉重启就会从 config server 加载配置信息，以后如果配置服务器信息变化会通知到所有的 mongos 更新自己的状态，这样 mongos 就能继续准确路由。在生产环境通常有多个 config server 配置服务器，因为它存储了分片路由的元数据，这个可不能丢失！就算挂掉其中一台，只要还有存货， mongodb集群就不会挂掉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;shard&lt;/code&gt;，这就是传说中的分片了。上面提到一个机器就算能力再大也有天花板，一台普通的机器做不了的多台机器来做，一台机器的一个数据表 Collection1 存储了 1T 数据，压力太大了！在分给4个机器后，每个机器都是256G，则分摊了集中在一台机器的压力。也许有人问一台机器硬盘加大一点不就可以了，为什么要分给四台机器呢？不要光想到存储空间，实际运行的数据库还有硬盘的读写、网络的IO、CPU和内存的瓶颈。在mongodb集群只要设置好了分片规则，通过mongos操作数据库就能自动把对应的数据操作请求转发到对应的分片机器上。在生产环境中分片的片键可要好好设置，这个影响到了怎么把数据均匀分到多个分片机器上，不要出现其中一台机器分了1T，其他机器没有分到的情况，如下图：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo16.jpg?raw=true&quot; alt=&quot;mongo16&quot; title=&quot;Title&amp;quot; &amp;quot;Title&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;replica set&lt;/code&gt;，其实上图4个分片如果没有 replica set 是个不完整架构，假设其中的一个分片挂掉那四分之一的数据就丢失了，所以在高可用性的分片架构还需要对于每一个分片构建 replica set 副本集保证分片的可靠性。生产环境通常是 2个副本 + 1个仲裁。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何搭建高可用的mongodb集群&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;首先确定各个组件的数量，mongos 3个， config server 3个，数据分3片 shard server 3个，每个shard 有一个副本一个仲裁也就是 3 * 2 = 6 个，总共需要部署15个实例。这些实例可以部署在独立机器也可以部署在一台机器，我们这里测试资源有限，只准备了3台机器，在同一台机器只要端口不同就可以，看一下物理部署图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo17.jpg?raw=true&quot; alt=&quot;mongo17&quot; title=&quot;Title&amp;quot; &amp;quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.准备机器，IP分别设置为： 192.168.0.1、192.168.0.2、192.168.0.3。&lt;/p&gt;

&lt;p&gt;2.分别在每台机器建立mongos 、config 、 shard1 、shard2、shard3 五个目录。 因为mongos不存储数据，只需要建立日志文件目录即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 建立mongos目录
$ mkdir -p ~/mongodbtest/mongos/log

# 建立config server数据文件存放目录
$ mkdir -p ~/mongodbtest/config/data

# 建立config server日志文件存放目录
$ mkdir -p ~/mongodbtest/config/log

# 建立shard1数据文件存放目录
$ mkdir -p ~/mongodbtest/shard1/data

# 建立shard1日志文件存放目录
$ mkdir -p ~/mongodbtest/shard1/log

# 建立shard2数据文件存放目录
$ mkdir -p ~/mongodbtest/shard2/data

# 建立shard2日志文件存放目录
$ mkdir -p ~/mongodbtest/shard2/log

# 建立shard3数据文件存放目录
$ mkdir -p ~/mongodbtest/shard3/data

# 建立shard3日志文件存放目录
$ mkdir -p ~/mongodbtest/shard3/log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.规划5个组件对应的端口号，由于一个机器需要同时部署 mongos、config server、shard1、shard2、shard3，所以需要用端口进行区分。这个端口可以自由定义，在本文 mongos为 20000，config server 为 21000， shard1为 22001，shard2为22002，shard3为22003.&lt;/p&gt;

&lt;p&gt;4.在每一台服务器分别启动配置服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mongod --configsvr --dbpath ~/mongodbtest/config/data --port 21000 --logpath 
~/mongodbtest/config/log/config.log --fork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.在每一台服务器分别启动mongos服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mongos --configdb 192.168.0.1:21000, 192.168.0.2:21000, 192.168.0.3:21000 
--port 20000 --logpath ~/mongodbtest/mongos/log/mongos.log --fork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.配置各个分片的副本集&lt;/p&gt;

&lt;p&gt;为了快速启动并节约测试环境存储空间，这里加上 nojournal 是为了关闭日志信息，在我们的测试环境不需要初始化这么大的redo日志。同样设置 oplogsize是为了降低 local 文件的大小，oplog是一个固定长度的 capped collection,它存在于”local”数据库中,用于记录Replica Sets操作日志。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 在每个机器里分别设置分片1服务及副本集shard1
$ ./mongod --shardsvr --replSet shard1 --port 22001 --dbpath ~/mongdbtest/shard1/data 
--logpath ~/mongdbtest/shard1/log/shard1.log --fork --nojournal --oplogSize 10

# 在每个机器里分别设置分片2服务及副本集shard2
$ ./mongod --shardsvr --replSet shard2 --port 22002 --dbpath ~/mongdbtest/shard2/data 
--logpath ~/mongdbtest/shard2/log/shard2.log --fork --nojournal --oplogSize 10

 # 在每个机器里分别设置分片3服务及副本集shard3
$ ./mongod --shardsvr --replSet shard3 --port 22003 --dbpath ~/mongdbtest/shard3/data 
--logpath ~/mongdbtest/shard3/log/shard3.log --fork --nojournal --oplogSize 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别对每个分片配置副本集，任意登陆一个机器，比如登陆192.168.0.1，连接MongoDB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 设置第一个分片副本集
$ ./mongo 192.168.0.1:22001
&amp;gt; use admin;
&amp;gt; config={_id:&quot;shard1&quot;, members:[{_id:0, host:&quot;192.168.0.1:22001&quot;},
{_id:1, host:&quot;192.168.0.2:22001&quot;},
{_id:2, host:&quot;192.168.0.3:22001&quot;,arbiterOnly:true}]}
&amp;gt; rs.initiate(config);

# 设置第二个分片副本集
$ ./mongo 192.168.0.1:22002
&amp;gt; use admin;
&amp;gt; config={_id:&quot;shard2&quot;, members:[{_id:0, host:&quot;192.168.0.1:22002&quot;},
{_id:1, host:&quot;192.168.0.2:22002&quot;},
{_id:2, host:&quot;192.168.0.3:22002&quot;,arbiterOnly:true}]}
&amp;gt; rs.initiate(config);

# 设置第三个分片副本集
$ ./mongo 192.168.0.1:22003
&amp;gt; use admin;
&amp;gt; config={_id:&quot;shard3&quot;, members:[{_id:0, host:&quot;192.168.0.1:22003&quot;},
{_id:1, host:&quot;192.168.0.2:22003&quot;},
{_id:2, host:&quot;192.168.0.3:22003&quot;,arbiterOnly:true}]}
&amp;gt; rs.initiate(config);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.目前搭建了mongodb配置服务器、路由服务器，各个分片服务器，不过应用程序连接到 mongos 路由服务器并不能使用分片机制，还需要在程序里设置分片配置，让分片生效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mongo 192.168.0.1:20000
&amp;gt; use admin;
# 串联路由服务器和分片副本集1
&amp;gt; db.runCommand({addshard:&quot;shard1/192.168.0.1:22001,192.168.0.2:22001,
192.168.0.3:22001&quot;});
# 串联路由服务器和分片副本集2
&amp;gt; db.runCommand({addshard:&quot;shard2/192.168.0.1:22002,192.168.0.2:22002,
192.168.0.3:22002&quot;});
# 串联路由服务器和分片副本集3
&amp;gt; db.runCommand({addshard:&quot;shard3/192.168.0.1:22003,192.168.0.2:22003,
192.168.0.3:22003&quot;}); 

# 查看分片服务器的配置
&amp;gt; db.runCommand({listshards: 1});
   
{
    &quot;shards&quot; : [
        {
            &quot;_id&quot;: &quot;shard1&quot;,
            &quot;host&quot;: &quot;shard1/192.168.0.1:22001,192.168.0.2:22001,192.168.0.3:22001&quot;
        },
        {
            &quot;_id&quot;: &quot;shard2&quot;,
            &quot;host&quot;: &quot;shard2/192.168.0.1:22002,192.168.0.2:22002,192.168.0.3:22002&quot;
        },
        {
            &quot;_id&quot;: &quot;shard3&quot;,
            &quot;host&quot;: &quot;shard3/192.168.0.1:22003,192.168.0.2:22003,192.168.0.3:22003&quot;
        }
    ],
    &quot;ok&quot;:1
}
因为192.168.0.3是每个分片副本集的仲裁节点，所以在上面结果没有列出来。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.连接在mongos上，准备让指定的数据库、指定的集合分片生效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 指定testdb分片生效

&amp;gt; db.runCommand({enablesharding:&quot;testdb&quot;})

# 指定数据里需要分片的集合和片键

&amp;gt; db.runCommand({shardcollection:&quot;testdb.table1&quot;, key:{id:1}})
#设置testdb的 table1 表需要分片，根据 id 自动分片到 shard1，shard2，shard3 上面去。
要这样设置是因为不是所有mongodb 的数据库和表都需要分片
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.测试分片结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 连接mongos服务器
$ ./mongos 192.168.0.1:20000
&amp;gt; use testdb;
&amp;gt; for (var i =1; i&amp;lt;10000; i++) db.table1.save({id:i,&quot;test1&quot;:&quot;testval1&quot;})
# 查看分片情况
&amp;gt; db.table1.stats()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.优化&lt;/p&gt;

&lt;p&gt;比如我们把所有的仲裁节点放在一台机器，其余两台机器承担了全部读写操作，但是作为仲裁的192.168.0.3相当空闲。让机器192.168.0.3多分担点责任吧！架构可以这样调整，把机器的负载分的更加均衡一点，每个机器既可以作为主节点、副本节点、仲裁节点，这样压力就会均衡很多了，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo18.jpg?raw=true&quot; alt=&quot;mongo18&quot; title=&quot;Title&amp;quot; &amp;quot;Title&quot; /&gt;&lt;/p&gt;

</description>
                <link>http://username.github.io/2017/01/06/mongodb</link>
                <guid>http://username.github.io/2017/01/06/mongodb</guid>
                <pubDate>Fri, 06 Jan 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>MongoDB副本集</title>
                <description>
&lt;p&gt;mongoDB官方已经不建议使用主从模式了，替代方案是采用副本集的模式。&lt;/p&gt;

&lt;p&gt;What’s Replica Sets(副本集)？&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;打魔兽世界总说打副本，其实这两个概念差不多一个意思。游戏里的副本是指玩家集中在高峰时间去一个场景打怪，会出现玩家暴多怪物少的情况，游戏开发商为了保证玩家的体验度，就为每一批玩家单独开放一个同样的空间同样的数量的怪物，这一个复制的场景就是一个副本，不管有多少个玩家各自在各自的副本里玩不会互相影响。&lt;/p&gt;

&lt;p&gt;mongoDB的副本也是这个，主从模式其实就是一个单副本的应用，没有很好的扩展性和容错性。而副本集具有多个副本保证了容错性，就算一个副本挂掉了还有很多副本存在，并且解决了主从模式的“主节点挂掉了，整个集群内会自动切换”问题。&lt;/p&gt;

&lt;p&gt;MongoDB副本集架构图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo5.jpg?raw=true&quot; alt=&quot;mongo5&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由图可以看到客户端连接到整个副本集，不关心具体哪一台机器是否挂掉。主服务器负责整个副本集的读写，副本集定期同步数据备份，一但主节点挂掉，副本节点就会选举一个新的主服务器，这一切对于应用服务器不需要关心。我们看一下主服务器挂掉后的架构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo6.jpg?raw=true&quot; alt=&quot;mongo6&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How to config Replica Sets?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;1.准备一台机器（有条件的话准备3台机器）&lt;/p&gt;

&lt;p&gt;2.创建三个副本集的文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir -p ~/mongodbtest/replset1
$ mkdir -p ~/mongodbtest/replset1/data
    
$ mkdir -p ~/mongodbtest/replset2
$ mkdir -p ~/mongodbtest/replset2/data
    
$ mkdir -p ~/mongodbtest/replset3
$ mkdir -p ~/mongodbtest/replset3/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.开3个终端分别启动mongodb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./mongod -dbpath ~/mongodbtest/replset1/data --replSet repset -port 27017
	
$ ./mongod -dbpath ~/mongodbtest/replset2/data --replSet repset -port 27018
	
$ ./mongod -dbpath ~/mongodbtest/replset3/data --replSet repset -port 27019
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo7.png?raw=true&quot; alt=&quot;mongo6&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.初始化副本集&lt;/p&gt;

&lt;p&gt;登录任意一个mongodb，这里我们选择27017&lt;/p&gt;

&lt;p&gt;$ ./mongo 127.0.0.1:27017&lt;/p&gt;

&lt;p&gt;定义副本集配置变量，这里的 _id:”repset” 和上面命令参数“ –replSet repset” 要保持一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo8.png?raw=true&quot; alt=&quot;mongo8&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看日志，副本集启动成功后&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo9.png?raw=true&quot; alt=&quot;mongo9&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看副本集状态&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo10.png?raw=true&quot; alt=&quot;mongo10&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5.测试副本集数据复制功能&lt;/p&gt;

&lt;p&gt;mongodb默认是从主节点读取数据的，副本节点上不允许读，需要设置副本节点可以读(setSlaveOk)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo11.png?raw=true&quot; alt=&quot;mongo11&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6.测试副本集故障转移功能&lt;/p&gt;

&lt;p&gt;杀掉27017主节点，查看27018、27019的日志可以看到经过一系列的投票选择操作，27019当选主节点，27018从27019同步数据过来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo12.png?raw=true&quot; alt=&quot;mongo12&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看整个集群的状态，可以看到27017为状态不可达。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo13.png?raw=true&quot; alt=&quot;mongo13&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再启动原来的主节点27017，发现27017变为 SECONDARY，还是27019为主节点 PRIMARY。&lt;/p&gt;

&lt;p&gt;7.副本集读写分离&lt;/p&gt;

&lt;p&gt;主节点的读写压力过大如何解决？常见的解决方案是读写分离，mongodb副本集的读写分离如何做呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/mongo14.jpg?raw=true&quot; alt=&quot;mongo14&quot; title=&quot;Title&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常规写操作来说并没有读操作多，所以一台主节点负责写，两台副本节点负责读。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;设置读写分离需要先在副本节点SECONDARY 设置 setSlaveOk。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在程序中设置副本节点负责读操作，如下代码（java）：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;public class TestMongoDBReplSetReadSplit {
    public static void main (String[] args) {
        try {
            List&amp;lt;ServerAddress&amp;gt; addresses = new ArrayList&amp;lt;ServerAddress&amp;gt;();
            ServerAddress address1 = new ServerAddress(&quot;127.0.0.1&quot;,27017);
            ServerAddress address2 = new ServerAddress(&quot;127.0.0.1&quot;,27018);
            ServerAddress address3 = new ServerAddress(&quot;127.0.0.1&quot;,27019);
            addresses.add(address1);
            addresses.add(address2);
            addresses.add(address3);
            MongoClient client = new MongoClient(addresses);
            DB db = client.getDB(&quot;test&quot;);
            DBCollection coll = db.getCollection(&quot;testdb&quot;);
                 
            BasicDBObject object = new BasicDBObject();
            object.append(&quot;test2&quot;, &quot;testval2&quot;);
                 
            // 读操作从副本节点读取
            ReadPreference preference = ReadPreference.secondary();
            DBObject dbObject = coll.findOne(object, null, preference);
                 
            System.out.println(dbObject);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读参数除了secondary一共还有五个参数：primary、primaryPreferred、secondary、secondaryPreferred、nearest。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;primary:默认参数，只从主节点上进行读取操作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;primaryPreferred:大部分从主节点上读取数据,只有主节点不可用时从secondary节点读取数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;secondary:只从secondary节点上进行读取操作，存在的问题是secondary节点的数据会比primary节点数据“旧”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;secondaryPreferred:优先从secondary节点进行读取操作，secondary节点不可用时从主节点读取数据；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nearest:不管是主节点、secondary节点，从网络延迟最低的节点上读取数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://username.github.io/2017/01/05/mongodb</link>
                <guid>http://username.github.io/2017/01/05/mongodb</guid>
                <pubDate>Thu, 05 Jan 2017 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>MongoDB介绍及配置</title>
                <description>
&lt;h2 id=&quot;whats-nosql&quot;&gt;What’s NoSQL?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。&lt;/p&gt;

&lt;p&gt;NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。&lt;/p&gt;

&lt;h2 id=&quot;why-nosql-&quot;&gt;Why NoSQL ?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。&lt;/p&gt;

&lt;h2 id=&quot;rdbms-vs-nosql&quot;&gt;RDBMS vs NoSQL&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;RDBMS&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高度组织化结构化数据&lt;/li&gt;
  &lt;li&gt;结构化查询语言（SQL） (SQL)&lt;/li&gt;
  &lt;li&gt;数据和关系都存储在单独的表中。&lt;/li&gt;
  &lt;li&gt;数据操纵语言，数据定义语言&lt;/li&gt;
  &lt;li&gt;严格的一致性&lt;/li&gt;
  &lt;li&gt;基础事务&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NoSQL&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代表着不仅仅是SQL&lt;/li&gt;
  &lt;li&gt;没有声明性查询语言&lt;/li&gt;
  &lt;li&gt;没有预定义的模式&lt;/li&gt;
  &lt;li&gt;键 - 值对存储，列存储，文档存储，图形数据库&lt;/li&gt;
  &lt;li&gt;最终一致性，而非ACID属性&lt;/li&gt;
  &lt;li&gt;非结构化和不可预知的数据&lt;/li&gt;
  &lt;li&gt;CAP定理&lt;/li&gt;
  &lt;li&gt;高性能，高可用性和可伸缩性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nosql-&quot;&gt;NoSQL 数据库分类&lt;/h2&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;类型&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;部分代表&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;特点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;列存储&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Hbase&lt;br /&gt;Cassandra&lt;br /&gt;Hypertable&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是按列存储数据的。&lt;br /&gt;最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，&lt;br /&gt;对针对某一列或者某几列的查询有非常大的IO优势。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;文档存储&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MongoDB&lt;br /&gt;CouchDB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;文档存储一般用类似json的格式存储，存储的内容是文档型的。&lt;br /&gt;这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;key-value存储&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tokyo Cabinet / Tyrant&lt;br /&gt;Berkeley DB&lt;br /&gt;MemcacheDB&lt;br /&gt;Redis&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;可以通过key快速查询到其value。&lt;br /&gt;一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;图存储&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Neo4J&lt;br /&gt;FlockDB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;对象存储&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;db4o&lt;br /&gt;Versant&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;xml数据库&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Berkeley DB XML&lt;br /&gt;BaseX&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;whats-mongodb&quot;&gt;What’s MongoDB&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;

&lt;p&gt;MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。支持类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。可以用sql操作MongoDB，从关系型数据库迁移过来，开发人员学习成本会大大减少。如果再对底层的sql API做一层封装，开发基本可以感觉不到mongodb和关系型数据库的区别。&lt;/p&gt;

&lt;h2 id=&quot;how-use-mongodb&quot;&gt;How use MongoDB&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;MongoDb的简单使用有以下两种方式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;单实例配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种配置只适合简易开发时使用，生产使用不行，因为单节点挂掉整个数据业务全挂，结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/mongo1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载&amp;amp;启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir -p mongodbtest/single 
$ mkdir -p mongodbtest/single/data
$ cd mongodbtest/single
$ wget http://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1204-3.4.1.tgz
$ tar xzvf mongodb-linux-x86_64-ubuntu1204-3.4.1.tgz
$ cd mongodb-linux-x86_64-ubuntu1204-3.4.1/bin
$ ./mongod --dpath ~/mongodbtest/single/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/mongo2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用ip+port访问：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/mongo3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主从模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;单实例模式的缺点就是单节点挂掉后，整个数据业务全挂，主从模式采用双机备份后主节点挂掉了后从节点可以接替主机继续服务。所以这种模式比单节点的高可用性要好很多。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/mongo4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面看一下怎么一步步搭建一个mongodb的主从复制节点：&lt;/p&gt;

&lt;p&gt;1.准备一台机器，既当作主节点，又作为从节点。&lt;/p&gt;

&lt;p&gt;2.建立文件夹 ~/mongodbtest/master 和 ~/mongodbtest/slave。&lt;/p&gt;

&lt;p&gt;3.启动mongodb主节点程序。注意后面的这个 “ –master ”参数，标示主节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod –dbpath ~/mongodbtest/master –master

# 输出日志如下，成功！
[initandlisten] MongoDB starting: pid=18285 port=27017 dbpath=~/mongodbtest/master master=1
#日志显示主节点参数
[initandlisten] options: { dbpath: “~/mongodbtest/master”, master: true }
[initandlisten] waiting for connections on port 27017
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.启动mongodb从节点程序。指定主节点ip地址和端口 –source 127.0.0.1:27017 和 标示从节点 –source 参数、端口号（区别于主节点）-port 27018。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod –dbpath ~/mongodbtest/slave –slave –source 192.168.0.1:27017 -port 27018

# 输出日志如下，成功！
[initandlisten] MongoDB starting : pid=17888 port=27018 dbpath=~/mongodbtest/slave slave=1
#日志显示从节点参数
[initandlisten] options: { dbpath: “~/mongodbtest/slave”, slave: true, source: “127.0.0.1:27018&quot; }
[initandlisten] waiting for connections on port 27018
#日志显示从节点 从主节点同步复制数据
[replslave] syncing from host:127.0.0.1:27018
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.该模式的缺点是：从服务器不可写，当master挂掉后，从服务器不会自动替代主服务器的功能，需要手工启动从服务器为master。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mongod –dbpath ~/mongodbtest/slave –master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.测试主从复制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;主节点：
# 连接
$ ./mongo 127.0.0.1:27017
# 建立test数据库
&amp;gt; use test;
# 往testdb表插入数据
&amp;gt; db.testdb.insert({&quot;test1&quot;:&quot;testval1&quot;});
# 查询
&amp;gt; db.testdb.find()
{&quot;_id&quot;: ObjectId(&quot;5284e6268ed115d6238bdb39&quot;), &quot;test1&quot; : &quot;testval1&quot;}
	
从节点：
# 连接
$ ./mongo 127.0.0.1:27018
# 查询数据库（会报错）
&amp;gt; show dbs;
{ 
	&quot;ok&quot;: 0,
	&quot;errmsg&quot;: &quot;not master and slaveOk=false&quot;
}
# 需要先设置slaveOk
&amp;gt; db.getMongo().setSlaveOk();
&amp;gt; db.testdb.find()
{&quot;_id&quot;: ObjectId(&quot;5284e6268ed115d6238bdb39&quot;), &quot;test1&quot; : &quot;testval1&quot;}
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.io/2016/12/30/mongodb</link>
                <guid>http://username.github.io/2016/12/30/mongodb</guid>
                <pubDate>Fri, 30 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>MySQL事务入门</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;InnoDB 和 MyISAM 的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。&lt;/p&gt;

&lt;p&gt;事务是由一组SQL语句组成逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务的ACID属性&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原子性(Atomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。&lt;/li&gt;
  &lt;li&gt;一致性(Consistent)：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。&lt;/li&gt;
  &lt;li&gt;隔离性(Isolation)：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。&lt;/li&gt;
  &lt;li&gt;持久性(Durable)：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;并发事务带来的问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相对于串行处理来说，并发处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;更新丢失(Lost Update)：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题—最后的更新覆盖了由其他事务所做的更新。&lt;/li&gt;
  &lt;li&gt;脏读(Dirty Reads)：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系，这种现象被形象地称为“脏读”。&lt;/li&gt;
  &lt;li&gt;不可重复读(Non-Repeatable Reads)：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生改变或某些记录已经被删除，这种现象就叫做“不可重复读”。&lt;/li&gt;
  &lt;li&gt;幻读(Phanton Reads)：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;事务隔离级别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“脏读”、“不可重复读”、“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，可以分为两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。&lt;/li&gt;
  &lt;li&gt;另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照(snapshot)，并用这个快照来提供一定级别(语句级或事务级)的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做&lt;code&gt;数据多版本并发控制(MultiVersion Concurrency Control)&lt;/code&gt;，也经常称为“多版本数据库”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据库的事务隔离越严格，并发副作用越小，但付出的代价越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。&lt;/p&gt;

&lt;p&gt;为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡“隔离”和“并发”的矛盾。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;隔离级别&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;读数据一致性&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;脏读&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;不可重复读&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;幻读&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;未提交读&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;最低级别，只能保证不读取物理上损坏的数据&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;已提交读&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;语句级&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;可重复读&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;事务级&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;是&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;可序列化&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;最高级别，事务级&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;各具体数据库并不一定完全实现了上述4个隔离级别，MySQL支持全部4个隔离级别，但是具体实现时，有一些特点。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事务控制&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;MySQL通过SET AUTOCOMMIT、START TRANSACTION、COMMIT和ROLLBACK等语句支持本地事务，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;START TRANSACTION|BEGIN[WORK]
COMMIT[WORK][AND [NO] CHAIN][NO][RELEASE]
ROLLBACK[WORK][AND [NO] CHAIN][NO][RELEASE]
SET AUTOCOMMIT = {0|1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，MySQL是自动提交的，如果需要通过明确的commit和rollback来提交和回滚事务，那么就需要通过明确的事务控制命令来开启事务，这是和Oracle的事务管理明显不同的地方。如果应用是从Oracle数据库迁移到MySQL数据库，则需要确保应用中是否对事务进行了明确的管理。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;START TRANSACTION或BEGIN语句可以开始一项新的事务。&lt;/li&gt;
  &lt;li&gt;COMMIT 和 ROLLBACK用来提交或者回滚事务。&lt;/li&gt;
  &lt;li&gt;CHAIN和RELEASE子句分别用来定义在事务提交或者回滚之后的操作，CHAIN会立即启动一个新事务，并且和刚才的事务具有相同的隔离级别，RELEASE则会断开和客户端的链接。&lt;/li&gt;
  &lt;li&gt;SET AUTOCOMMIT可以修改当前连接的提交方式，如果设置为0，则设置之后所有事务都需要通过明确的命令进行提交或者回滚。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://username.github.io/2016/12/14/mysql</link>
                <guid>http://username.github.io/2016/12/14/mysql</guid>
                <pubDate>Wed, 14 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>MySQL索引</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4个页面，如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;索引的类型&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设有如下一个表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE People (
	last_name varchar(50)    not null,
	first_name varchar(50)    not null,
	dob        date           not null,
	gender     enum(&#39;m&#39;, &#39;f&#39;) not null,
	key(last_name, first_name, dob)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其索引包含表中每一行的last_name、first_name和dob列。其结构大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/mysql2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，当然，如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。&lt;/li&gt;
  &lt;li&gt;匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。&lt;/li&gt;
  &lt;li&gt;匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。&lt;/li&gt;
  &lt;li&gt;匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。&lt;/li&gt;
  &lt;li&gt;匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。&lt;/li&gt;
  &lt;li&gt;仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Hash索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的，如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。&lt;/p&gt;

&lt;p&gt;假设创建如下一个表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE testhash (
	fname VARCHAR(50) NOT NULL,
	lname VARCHAR(50) NOT NULL,
	KEY USING HASH(fname)
) ENGINE=MEMORY;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设索引使用hash函数f( )，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f(&#39;Arjen&#39;) = 2323

f(&#39;Baron&#39;) = 7437

f(&#39;Peter&#39;) = 8784

f(&#39;Vadim&#39;) = 2458
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，索引的结构大概如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Slot&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2323&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2458&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7437&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8784&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Slots是有序的，但是记录不是有序的。当你执行
mysql&amp;gt; SELECT lname FROM testhash WHERE fname=’Peter’;
MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f(‘Peter’) = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。
因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。&lt;/p&gt;

&lt;p&gt;Hash索引有以下一些限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。&lt;/li&gt;
  &lt;li&gt;不能使用hash索引排序。&lt;/li&gt;
  &lt;li&gt;Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。&lt;/li&gt;
  &lt;li&gt;Hash索引只支持等值比较，例如使用=，IN( )和&amp;lt;=&amp;gt;。对于WHERE price&amp;gt;100并不能加速查询。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用索引&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;普通索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–直接创建索引
CREATE INDEX index_name ON table(column(length)	
–修改表结构的方式添加索引
ALTER TABLE table_name ADD INDEX index_name ON (column(length))

–创建表的时候同时创建索引
CREATE TABLE `table` (
	`id` int(11) NOT NULL AUTO_INCREMENT ,
	`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
	`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
	`time` int(10) NULL DEFAULT NULL ,
	PRIMARY KEY (`id`),
	INDEX index_name (title(length))
)

–删除索引
DROP INDEX index_name ON table
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–创建唯一索引
CREATE UNIQUE INDEX indexName ON table(column(length))

–修改表结构
ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))

–创建表的时候直接指定

CREATE TABLE `table` (
	`id` int(11) NOT NULL AUTO_INCREMENT ,
	`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
	`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
	`time` int(10) NULL DEFAULT NULL ,
	PRIMARY KEY (`id`),
	UNIQUE indexName (title(length))
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;全文索引（FULLTEXT）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。&lt;/p&gt;

&lt;p&gt;对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–创建表的适合添加全文索引
CREATE TABLE `table` (
	`id` int(11) NOT NULL AUTO_INCREMENT ,
	`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
	`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
	`time` int(10) NULL DEFAULT NULL ,
	PRIMARY KEY (`id`),
	FULLTEXT (content)
);

–修改表结构添加全文索引
ALTER TABLE article ADD FULLTEXT index_content(content)

–直接创建索引
CREATE FULLTEXT INDEX index_content ON article(content)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;单列索引、多列索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组合索引（最左前缀）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;– title,time
– title
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面的几个SQL所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–使用到上面的索引

SELECT * FROM article WHREE title=&#39;测试&#39; AND time=1234567890;
SELECT * FROM article WHREE utitle=&#39;测试&#39;;

–不使用上面的索引

SELECT * FROM article WHREE time=1234567890;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;设计索引的原则&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;索引的设计可以遵循一些已有的原则，创建索引的时候尽量考虑符合这些原则。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;搜索的索引列，不一定是所要选择的列。最适合索引的列是出现再where子句中的列，或连接子句中指定的列，而不是出现在select关键字后的选择列表中的列。&lt;/li&gt;
  &lt;li&gt;使用唯一索引。考虑考虑某列中值的分布。索引的列的基数越大，索引的效果越好。例如，存放出生日期的列具有不同值，但很容易区分各行。而用来记录性别的列，只含有“M”和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。&lt;/li&gt;
  &lt;li&gt;使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘IO较少，较短的值比较起来更快。对于较短的键值，索引高速缓存中的块能容纳更多的键值。&lt;/li&gt;
  &lt;li&gt;利用最左前缀。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引，多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。&lt;/li&gt;
  &lt;li&gt;不要过度索引。不要以为索引“越多越好”，每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。如果有一个索引很少利用或从来不用，那么会不必要的减缓表的修改速度。&lt;/li&gt;
  &lt;li&gt;对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以innodb表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询效率。另外，innodb表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果。&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://username.github.io/2016/12/13/mysql</link>
                <guid>http://username.github.io/2016/12/13/mysql</guid>
                <pubDate>Tue, 13 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>MySQL存储引擎介绍</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;插件式存储引擎是MySQL数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。MySQL默认支持多种存储引擎，以适用于不同领域的数据应用需要、用户可以选择不同的存储引擎提高应用的效率、提供灵活的存储，用户甚至可以按照自己的需要定制和使用自己的存储引擎，以实现最大程度的可定制型。&lt;/p&gt;

&lt;p&gt;MySQL 5.0支持的存储引擎包括MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎都是非事务安全表。&lt;/p&gt;

&lt;p&gt;创建新表时如果不指定存储引擎，那么系统就会使用默认存储引擎，MySQL 5.5 之前默认存储引擎室MyISAM，5.5之后改为了InnoDB。如果要修改默认存储引擎，可以在参数文件中设置default-table-type。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 查看当前默认存储引擎：

mysql&amp;gt; show variables like &#39;table_type&#39;;

+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| table_type    | MyISAM |
+---------------+--------+

2. 查看当前数据版本支持（Support）的存储引擎和默认(Default)存储引擎

mysql&amp;gt; show engines \G;

*************************** 1. row ***************************
      Engine: ndbcluster
     Support: NO
     Comment: Clustered, fault-tolerant tables
Transactions: NULL
      	  XA: NULL
  Savepoints: NULL
*************************** 2. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
	  Engine: BLACKHOLE
 	 Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
  		  XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MEMORY
     Support: YES
 	 Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
  	      XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 7. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
  	  Engine: InnoDB
 	 Support: YES
 	 Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
	      XA: YES
  Savepoints: YES
*************************** 9. row ***************************
      Engine: MyISAM
     Support: DEFAULT
     Comment: Default engine as of MySQL 3.23 with great performance
Transactions: NO
    	  XA: NO
  Savepoints: NO

3. 查看支持的存储引擎

mysql&amp;gt; show variables like &#39;have%&#39;;
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| have_community_features | YES      |
| have_compress           | YES      |
| have_crypt              | YES      |
| have_csv                | YES      |	
| have_dynamic_loading    | YES      |
| have_geometry           | YES      |
| have_innodb             | YES      |
| have_ndbcluster         | DISABLED |
| have_openssl            | NO       |
| have_partitioning       | YES      |
| have_query_cache        | YES      |
| have_rtree_keys         | YES      |
| have_ssl                | NO       |
| have_symlink            | DISABLED |
+-------------------------+----------+

其中value为DISABLED的记录表示支持该存储引擎，但是数据库启动时被禁用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;常用存储引擎的特点&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MyISAM 不支持事务、也不支持外键，其优点是访问速度快，对事务完整性没有要求或者以select、insert为主的应用基本上都可以使用MyISAM来创建表。&lt;/p&gt;

&lt;p&gt;每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但扩展名分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.frm (存储表定义)&lt;/li&gt;
  &lt;li&gt;.MYD (MYData，存储数据)&lt;/li&gt;
  &lt;li&gt;.MYI (MYIndex，存储索引)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据文件和索引文件可以放置在不同的目录，平均分配IO，获得更快的速度。在创建表的时候可以通过DATA DIRECTORY 和 INDEX DIRECTORY 语句指定索引文件和数据文件的路径，也就是说不同MyISAM 表的索引文件和数据文件可以放置到不同的路径下，文件路径需要是绝对路径，并且具有访问权限。&lt;/p&gt;

&lt;p&gt;MyISAM 类型的表可能会损坏，损坏后的表可能不能被访问，会提示需要修复或者访问后返回错误的结果。MyISAM 类型的表提供修复工具，可以用check table语句来检查MyISAM表的健康，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHECK TABLE tbl_name [, tbl_name] ... [option] ...

option = {
	FOR UPGRADE
  		| QUICK
  		| FAST
  		| MEDIUM
  		| EXTENDED
  		| CHANGED
}

mysql&amp;gt; check table questions;
+--------------------------+-------+----------+----------+
| Table                    | Op    | Msg_type | Msg_text |
+--------------------------+-------+----------+----------+
| feedback.questions 		| check | status   | OK       |
+--------------------------+-------+----------+----------+	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;损坏的MyISAM表可以使用REPAIR TABLE 语句修复，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;REPAIR [NO_WRITE_TO_BINLOG | LOCAL] TABLE
tbl_name [, tbl_name] ...
[QUICK] [EXTENDED] [USE_FRM]

mysql&amp;gt; repair table questions;
+--------------------------+--------+----------+----------+
| Table                    | Op     | Msg_type | Msg_text |
+--------------------------+--------+----------+----------+
| feedback.questions 		| repair | status   | OK       |
+--------------------------+--------+----------+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyISAM 表支持3种不同的存储格式，分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态表 默认 记录固定长度 优点：存储快 缺点：占用空间大&lt;/li&gt;
  &lt;li&gt;动态表 变长字段  优点：占用空间少  缺点：频繁更新和删除记录容易产生碎片&lt;/li&gt;
  &lt;li&gt;压缩表 每个记录被单独压缩，占据非常小的磁盘空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;InnoDB 具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。&lt;/p&gt;

&lt;p&gt;1、自动增长列&lt;/p&gt;

&lt;p&gt;InnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者0，则实际插入的将是自动增长后的值。可以通过”ALTER TABLE *** AUTO_INCREMENT=n;” 语句强制设置自动增长列的初始值，默认从1开始，但是该强制的默认值是保留在内存中的，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。&lt;/p&gt;

&lt;p&gt;可以使用LAST_INSERT_ID()查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select last_insert_id();
+------------------+
| last_insert_id() |
+------------------+
|               40 |
+------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。&lt;/p&gt;

&lt;p&gt;2、外键约束&lt;/p&gt;

&lt;p&gt;MySQL 支持外键的存储引擎只有InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。&lt;/p&gt;

&lt;p&gt;在创建索引时，可以指定在删除、更新父表时，对子表进行的相应操作，包括RESTRICT、NO ACTION、CASCADE、SET NULL。其中RESTRICT和NO ACTION相同，是指限制在子表有关联记录的情况下父表不能更新；CASCADE 表示父表在更新或删除时，更新或删除子表对应记录；SET NULL 则表示父表在更新或删除时，子表对应字段被SET NULL。&lt;/p&gt;

&lt;p&gt;当某个表被其他表创建了外键参照，那么该表的对应索引或主键禁止被删除。&lt;/p&gt;

&lt;p&gt;在导入多个表的数据时，如果需要忽略表之前的导入顺序，可以暂时关闭外键的检查；同样，在执行LOAD DATA和ALTER TABLE操作时，可以通过暂时关闭外键约束来加快处理的速度，关闭和打开外键约束的命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SET FOREIGN_KEY_CHECKS = 0;
SET FOREIGN_KEY_CHECKS = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、存储方式&lt;/p&gt;

&lt;p&gt;InnoDB的表空间结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/mysql1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InnoDB存储表和索引有以下两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件。&lt;/li&gt;
  &lt;li&gt;使用多表空间（又称单独表空间）存储，这种方式创建的表的表结构仍然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中。如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”，可以在创建分区时指定每个分区的数据文件位置，以此来将表的IO均匀分布在多个磁盘上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在InnoDB存储引擎中，默认表空间文件是ibdata1，初始化为10M，且可以扩展:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &#39;innodb_data%&#39;;
+-----------------------+------------------------+
| Variable_name         | Value                  |
+-----------------------+------------------------+
| innodb_data_file_path | ibdata1:10M:autoextend |
| innodb_data_home_dir  |                        |
+-----------------------+------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用共享表空间存储方式时，Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。&lt;/p&gt;

&lt;p&gt;而在使用多表空间存储方式时，每个表的数据以一个单独的文件来存放，这个时候的单表限制，又变成文件系统的大小限制了。不同平台下，多表空间文件最大限度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Operating System  File-size Limit
Win32 w/ FAT/FAT32  2GB/4GB
Win32 w/ NTFS          2TB (possibly larger)
Linux 2.4+          (using ext3 file system) 4TB
Solaris 9/10          16TB
MacOS X w/ HFS+         2TB
NetWare w/NSS file system  8TB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共享表空间与多表空间可以通过在my.cnf中设置参数innodb_file_per_table来转换，若为1，则开启多表空间，否则，开启共享表存储。并且重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &#39;innodb_file%&#39;;
+------------------------+-------+
| Variable_name          | Value |	
+------------------------+-------+	
| innodb_file_io_threads | 4     |
| innodb_file_per_table  | OFF   |
+------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制.ibd文件是不行的，因为没有共享表空间的数据字典信息，直接复制的.ibd文件和.frm文件恢复时是不能被正确识别的，但是可以通过下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE tbl_name DISCARD TABLESPACE;
ALTER TABLE tble_name IMPORT TABLESPACE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将备份恢复到数据库中，但是这样的单表备份，只能恢复到表原来所在的数据库中，而不能恢复到其他的数据库中。如果要将单表恢复到目标数据库，则需要通过mysqldump和mysqlimport来实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;即便在多表空间的存储方式下，共享表空间仍然是必须的，Innodb把内部数据词典和在线重做日志放在这个文件中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;MEMORY&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MEMORY 存储引擎将所有数据保存在RAM中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY的缺陷是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据异常终止后表的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用于快速得到访问结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MERGE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用它们。MERGE表的优点在于可以突破对单个MyISAM表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用存储引擎的对比&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;特点&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MyISAM&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;InnoDB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MEMORY&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MERGE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;存储限制&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;有&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;64TB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;有&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;没有&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;事务安全&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;锁机制&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表锁&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;行锁&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表锁&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B树索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;哈希索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;全文索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;集群索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;数据缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;索引缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;数据可压缩&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;空间使用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;N/A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;内存使用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;中等&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;批量插入速度&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持外键&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
                <link>http://username.github.io/2016/12/12/mysql</link>
                <guid>http://username.github.io/2016/12/12/mysql</guid>
                <pubDate>Mon, 12 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>MySql外键介绍</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;基本概念&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;MySQL中“键”和“索引”的定义相同，所以外键和主键一样也是索引的一种。不同的是MySQL会自动为所有表的主键进行索引，但是外键字段必须由用户进行明确的索引。用于外键关系的字段必须在所有的参照表中进行明确地索引，InnoDB不能自动地创建索引。&lt;/p&gt;

&lt;p&gt;外键可以是一对一的，一个表的记录只能与另一个表的一条记录连接，或者是一对多的，一个表的记录与另一个表的多条记录连接。&lt;/p&gt;

&lt;p&gt;如果需要更好的性能，并且不需要完整性检查，可以选择使用MyISAM表类型，如果想要在MySQL中根据参照完整性来建立表并且希望在此基础上保持良好的性能，最好选择表结构为innoDB类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;参照完整性&lt;/code&gt;：当外键与另一个表的字段有关系，而且这种关系是惟一时，这个系统就称为处于参照完整性的状态。也就是说，如果一个字段在所有的表中只出现一次，而且每个表的这个字段的变化都会影响其他表，这就是存在参照完整性。&lt;/p&gt;

&lt;p&gt;外键的好处：可以使得两张表关联，保证数据的一致性和实现一些级联操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;级联操作&lt;/code&gt;：外键可以保证新插入的记录的完整性。但是，如果在REFERENCES从句中从已命名的表删除记录会怎样？在使用同样的值作为外键的辅助表中会发生什么？很明显，那些记录也应该被删除，否则在数据库中就会有很多无意义的孤立记录。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;外键的使用条件&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;两个表必须是InnoDB表，MyISAM表暂时不支持外键&lt;/li&gt;
  &lt;li&gt;外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显式建立；&lt;/li&gt;
  &lt;li&gt;外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;使用方法&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;外键的定义语法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[CONSTRAINT symbol] FOREIGN KEY [id] (index_col_name, ...)
	REFERENCES tbl_name (index_col_name, ...)
	[ON DELETE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]
	[ON UPDATE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]
	
该语法可以在 CREATE TABLE 和 ALTER TABLE 时使用，如果不指定CONSTRAINT symbol，MYSQL会自动生成一个名字。

ON DELETE、ON UPDATE表示事件触发限制，可设参数：
① RESTRICT（限制外表中的外键改动，默认值）
② CASCADE（跟随外键改动）
③ SET NULL（设空值）
④ SET DEFAULT（设默认值）
⑤ NO ACTION（无动作，默认的）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;创建表1
	create table repo_table(
		repo_id char(13) not null primary key,
		repo_name char(14) not null
	) type=innodb;

创建表2
	create table busi_table(
		busi_id char(13) not null primary key,
		busi_name char(13) not null,
		repo_id char(13) not null,
		foreign key(repo_id) references repo_table(repo_id)
	) type=innodb;

插入数据
	insert into repo_table values(&quot;12&quot;,&quot;sz&quot;); //success
	insert into repo_table values(&quot;13&quot;,&quot;cd&quot;); //success
	insert into busi_table values(&quot;1003&quot;,&quot;cd&quot;, &quot;13&quot;); //success
	insert into busi_table values(&quot;1002&quot;,&quot;sz&quot;, &quot;12&quot;); //success
	insert into busi_table values(&quot;1001&quot;,&quot;gx&quot;, &quot;11&quot;); //failed,
	错误提示：ERROR 1452 (23000): Cannot add or update a child row: 
	a foreign key constraint fails (`smb_man`.`busi_table`, 
	CONSTRAINT `busi_table_ibfk_1` FOREIGN KEY (`repo_id`) REFERENCES `repo_table` (`repo_id`))
	
增加级联操作
	alter table busi_table add constraint id_check foreign key(repo_id)
	references repo_table(repo_id) on delete cascade on update cascade;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;外键约束（表2）对父表（表1）的含义:&lt;/p&gt;

&lt;p&gt;在父表上进行update/delete以更新或删除在子表中有一条或多条对应匹配行的候选键时，父表的行为取决于：在定义子表的外键时指定的on update/on delete子句。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CASCADE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;删除包含与已删除键值有参照关系的所有记录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SET NULL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;修改包含与已删除键值有参照关系的所有记录，使用NULL值替换(只能用于已标记为NOT NULL的字段)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RESTRICT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;拒绝删除要求，直到使用删除键值的辅助表被手工删除，并且没有参照时(这是默认设置，也是最安全的设置)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;NO ACTION&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;啥也不做&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在外键上建立索引:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index repo_id (repo_id),
foreign key(repo_id) references repo_table(repo_id))
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.io/2016/12/09/mysql</link>
                <guid>http://username.github.io/2016/12/09/mysql</guid>
                <pubDate>Fri, 09 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Linux的Cached Memory</title>
                <description>
&lt;h2 id=&quot;cache&quot;&gt;文件Cache&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在 Linux 操作系统中，当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从存储设备读入到这些内存中，然后再将数据分发给应用程序；当需要往文件中写数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。&lt;/p&gt;

&lt;p&gt;文件 Cache 管理指的就是对这些由操作系统分配，并用来存储文件数据的内存的管理。 Cache 管理的优劣通过两个指标衡量：一是 Cache 命中率，Cache 命中时数据可以直接从内存中获取，不再需要访问低速外设，因而可以显著提高性能；二是有效 Cache 的比率，有效 Cache 是指真正会被访问到的 Cache 项，如果有效 Cache 的比率偏低，则相当部分磁盘带宽会被浪费到读取无用 Cache 上，而且无用 Cache 会间接导致系统内存紧张，最后可能会严重影响性能。&lt;/p&gt;

&lt;p&gt;文件 Cache 是文件数据在内存中的副本，因此文件 Cache 管理与内存管理系统和文件系统都相关：一方面文件 Cache 作为物理内存的一部分，需要参与物理内存的分配回收过程，另一方面文件 Cache 中的数据来源于存储设备上的文件，需要通过文件系统与存储设备进行读写交互。从操作系统的角度考虑，文件 Cache 可以看做是内存管理系统与文件系统之间的联系纽带。因此，文件 Cache 管理是操作系统的一个重要组成部分，它的性能直接影响着文件系统和内存管理系统的性能。&lt;/p&gt;

&lt;p&gt;图 1 描述了 Linux 操作系统中文件 Cache 管理与内存管理以及文件系统的关系示意图。从图中可以看到，在 Linux 中，具体文件系统，如 ext2/ext3、jfs、ntfs 等，负责在文件 Cache和存储设备之间交换数据，位于具体文件系统之上的虚拟文件系统VFS负责在应用程序和文件 Cache 之间通过 read/write 等接口交换数据，而内存管理系统负责文件 Cache 的分配和回收，同时虚拟内存管理系统(VMM)则允许应用程序和文件 Cache 之间通过 memory map的方式交换数据。可见，在 Linux 系统中，文件 Cache 是内存管理系统、文件系统以及应用程序之间的一个联系枢纽。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/cache.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cache-1&quot;&gt;文件Cache数据结构&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在 Linux 的实现中，文件 Cache 分为两个层面，一是 Page Cache，另一个 Buffer Cache，每一个 Page Cache 包含若干 Buffer Cache。内存管理系统和 VFS 只与 Page Cache 交互，内存管理系统负责维护每项 Page Cache 的分配和回收，同时在使用 memory map 方式访问时负责建立映射；VFS 负责 Page Cache 与用户空间的数据交换。而具体文件系统则一般只与 Buffer Cache 交互，它们负责在外围存储设备和 Buffer Cache 之间交换数据。Page Cache、Buffer Cache、文件以及磁盘之间的关系如图 2 所示，Page 结构和 buffer_head 数据结构的关系如图 3 所示。在上述两个图中，假定了 Page 的大小是 4K，磁盘块的大小是 1K。本文所讲述的，主要是指对 Page Cache 的管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/cache1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/cache2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache 项，一个是 radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux 内核利用这个数据结构来通过文件内偏移快速定位 Cache 项，图 4 是 radix tree的一个示意图，该 radix tree 的分叉为4(22)，树高为4，用来快速定位8位文件内偏移。Linux(2.6.7) 内核中的分叉为 64(26)，树高为 6(64位系统)或者 11(32位系统)，用来快速定位 32 位或者 64 位偏移，radix tree 中的每一个叶子节点指向文件内相应偏移所对应的Cache项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/cache3.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另一个数据结构是双向链表，Linux内核为每一片物理内存区域(zone)维护active_list和inactive_list两个双向链表，这两个list主要用来实现物理内存的回收。这两个链表上除了文件Cache之外，还包括其它匿名(Anonymous)内存，如进程堆栈等。&lt;/p&gt;

&lt;h2 id=&quot;cache-2&quot;&gt;文件Cache预读和替换&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Linux内核中文件预读算法的具体过程是这样的：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面(不少于一个页面，通常是三个页面)，这时的预读称为&lt;code&gt;同步预读&lt;/code&gt;。对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的group中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读group扩大一倍，并让底层文件系统读入group中剩下尚不在Cache中的文件数据块，这时的预读称为&lt;code&gt;异步预读&lt;/code&gt;。无论第二次读请求是否命中，系统都要更新当前预读group的大小。&lt;/p&gt;

&lt;p&gt;此外，系统中定义了一个window，它包括前一次预读的group和本次预读的group。任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读window中，这时继续进行异步预读并更新相应的window和group；第二种情况是所请求的页面处于预读window之外，这时系统就要进行同步预读并重置相应的window和group。图5是Linux内核预读机制的一个示意图，其中a是某次读操作之前的情况，b是读操作所请求页面不在window中的情况，而c是读操作所请求页面在window中的情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/cache4.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linux内核中文件Cache替换的具体过程是这样的：刚刚分配的Cache项链入到inactive_list头部，并将其状态设置为active，当内存不够需要回收Cache时，系统首先从尾部开始反向扫描active_list并将状态不是referenced的项链入到inactive_list的头部，然后系统反向扫描inactive_list，如果所扫描的项的处于合适的状态就回收该项，直到回收了足够数目的Cache项。&lt;/p&gt;

&lt;h2 id=&quot;linux-cache&quot;&gt;Linux Cache查看&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;使用命令 cat /proc/meminfo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MemTotal:       65951816 kB
MemFree:         5619132 kB
Buffers:          973232 kB
Cached:         42700380 kB
SwapCached:            0 kB
Active:         40573736 kB
Inactive:       15884684 kB
Active(anon):   12211624 kB
Inactive(anon):  1134312 kB
Active(file):   28362112 kB
Inactive(file): 14750372 kB
Unevictable:        1892 kB
Mlocked:               0 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:             37940 kB
Readahead	        0 kB
Writeback:             0 kB
AnonPages:      12786760 kB
Mapped:           317028 kB
Shmem:            559224 kB
Slab:            2973088 kB
SReclaimable:    2860064 kB
SUnreclaim:       113024 kB
KernelStack:       14592 kB
PageTables:       164732 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:    32975908 kB
Committed_AS:   36035680 kB
VmallocTotal:   34359738367 kB
VmallocUsed:      384232 kB
VmallocChunk:   34323892400 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:        6152 kB
DirectMap2M:    67082240 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过free -g(-m)命令观察系统的内存使用情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	        total       used       free     shared    buffers     cached
Mem:            62         57          5          0          0         40
-/+ buffers/cache:         15         47
Swap:            0          0          0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第一行用全局角度描述系统使用的内存状况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total——总物理内存 used——已使用内存，一般情况这个值会比较大，total=used+free
used 已经使用的内存数  used=buffers+cached (maybe add shared also) 
free——完全未被使用的内存 shared——应用程序共享内存 
buffers——缓存，主要用于目录方面,inode值等（ls大目录可看到这个值增加） 
cached——缓存，用于已打开的文件 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行描述应用程序的内存使用： &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;前个值表示-buffers/cache——应用程序使用的内存大小，used减去缓存值 
后个值表示+buffers/cache——所有可供应用程序使用的内存大小，free加上缓存值 
  
-buffers/cache=used-buffers-cached 
+buffers/cache=free+buffers+cached 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三行表示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swap的使用：used——已使用 free——未使用
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cache-3&quot;&gt;手动释放Cache（不建议）&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;/proc 是一个虚拟文件系统,我们可以通过对它的读写操作做为与kernel实体间进行通信的一种手段.也就是说可以通过修改/proc中的文件,来对当前 kernel的行为做出调整.那么我们可以通过调整/proc/sys/vm/drop_caches来释放内存.操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先查看/proc/sys/vm/drop_caches的值,默认为0：
# cat /proc/sys/vm/drop_caches
#	0

然后同步一下数据：	
#sync
(执行sync命令(描述:sync命令运行sync子例程。如果必须停止系统，则运行sync命令以确保文件系统的完整性。
sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的i-node、已延迟的块I/O和读写映射文件)


最后修改/proc/sys/vm/drop_caches：

To free  pagecache,  
use  echo 1 &amp;gt; /proc/sys/vm/drop_caches; 
to free dentries and inodes, 
use echo 2 &amp;gt; /proc/sys/vm/drop_caches;
to free pagecache, dentries  and  inodes,  
use echo 3 &amp;gt; /proc/sys/vm/drop_caches.
&lt;/code&gt;&lt;/pre&gt;

</description>
                <link>http://username.github.io/2016/12/08/linuxcached-memory</link>
                <guid>http://username.github.io/2016/12/08/linuxcached-memory</guid>
                <pubDate>Thu, 08 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Spring Annotation详解</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;注解（Annotation）提供了一种安全的类似注释的机制，为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻方便的使用这些数据（通过解析注解来使用这些数据），用来将任何的信息或者元数据与程序元素（类、方法、成员变量等）进行关联。其实就是更加直观更加明了的说明，这些说明信息与程序业务逻辑没有关系，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的申明语句中。&lt;/p&gt;

&lt;p&gt;Annotation其实是一种接口。通过Java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;注解&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;@RequestMapping&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;类：
@Controller 
@RequestMapping(&quot;/feedback&quot;)
public class FeedbackController {
	@RequestMapping(&quot;/listFeedback&quot;)
	http://localhost/feedback/listFeedback&amp;amp;topicId=1&amp;amp;userId=10&amp;amp;userName=tom
	或者@RequestMapping(params = &quot;method=listFeedback&quot;)
	http://localhost/feedback?method=listFeedback&amp;amp;id=1&amp;amp;userId=10&amp;amp;userName=tom
	public String listFeedback(int id,User user) {}
}

方法：
@RequestMapping(&quot;/feedback/submit&quot;)
@RequestMapping(value=&quot;/feedback/submit&quot;,method = POST)
@RequestMapping(value=&quot;/feedback/submit&quot;,params={&quot;modify=false&quot;}, method=POST)

说明：
@RequestMapping 可以声明到类或方法上

参数绑定说明：
http://localhost/feedback?method=listFeedback&amp;amp;id=1&amp;amp;userId=10&amp;amp;userName=tom
id 参数将绑定到id入参上，而userId和userName URL参数将绑定到user对象的 userId和userName 属性中。
URL 请求中不允许没有 id 参数，否则报错，User的userId属性的类型是基本数据类型，
如果URL中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。
如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。

其他：
@RequestMapping(value = &quot;/test&quot;, consumes=&quot;application/json&quot;) 
仅处理request Content-Type为“application/json”类型的请求。

@RequestMapping(value = &quot;/test/{id}&quot;, produces=&quot;application/json&quot;)
仅处理request请求中Accept头中包含了&quot;application/json&quot;的请求，
同时暗示了返回的内容类型为application/json

支持正则表达式
@RequestMapping(value=&quot;/{textualPart:[a-z-]+}.{numericPart:[\\d]+}&quot;)  
public String regularExpression( @PathVariable String textualPart, 
	@PathVariable String numericPart){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类：（主要讲解常用类型）&lt;/p&gt;

&lt;p&gt;A、处理requet uri 部分（这里指uri template中variable，不含queryString部分）的注解：   @PathVariable;&lt;/p&gt;

&lt;p&gt;B、处理request header部分的注解：   @RequestHeader, @CookieValue;&lt;/p&gt;

&lt;p&gt;C、处理request body部分的注解：@RequestParam,  @RequestBody;&lt;/p&gt;

&lt;p&gt;D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@PathVariable&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.例如
@Controller  
@RequestMapping(&quot;/owners/{ownerId}&quot;)  
public class RelativePathUriTemplateController {  
	@RequestMapping(&quot;/pets/{petId}&quot;)  
	public void findPet(@PathVariable String ownerId, @PathVariable String petId, 
		Model model) {      
		// implementation omitted  
	}  
}
.说明  
当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 
这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@RequestHeader&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
可以把Request请求header部分的值绑定到方法的参数上。

.例如
这是一个Request 的header部分：
Host                    localhost:8080  
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9  
Accept-Language         fr,en-gb;q=0.7,en;q=0.3  
Accept-Encoding         gzip,deflate  
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7  
Keep-Alive  


@RequestMapping(&quot;/displayHeaderInfo.do&quot;)  
public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,  
	@RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  {}
                          
上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， 
Keep-Alive header的值绑定到参数keepAlive上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@CookieValue&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
可以把Request header中关于cookie的值绑定到方法的参数上。 

.例如
有如下Cookie值：JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
@RequestMapping(&quot;/displayHeaderInfo.do&quot;)  
public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@RequestParam&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;参数绑定说明
@RequestParam(&quot;id&quot;)
http://localhost/bbtForum.do?method=listBoardTopic&amp;amp;id=1&amp;amp;userId=10&amp;amp;userName=tom
listBoardTopic(@RequestParam(&quot;id&quot;)int topicId,User user)中的topicId绑定到id这个参数， 
那么可以通过对入参使用 @RequestParam 注解来达到目的

@RequestParam(required=false)：参数不是必须的，默认为true
@RequestParam(value=&quot;id&quot;,required=false)

请求处理方法入参的可选类型
• Java 基本数据类型和 String
  默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则

• request/response/session
  既可以是Servlet API的也可以是Portlet API对应的对象，Spring会将它们绑定到Servlet和Portlet容器
  的相应对象上

• org.springframework.web.context.request.WebRequest
  内部包含了 request 对象

• java.util.Locale
  绑定到 request 对应的 Locale 对象上

• java.io.InputStream/java.io.Reader
  可以借此访问 request 的内容

• java.io.OutputStream / java.io.Writer
  可以借此操作 response 的内容

• 任何标注了 @RequestParam 注解的入参
  被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。

• java.util.Map / org.springframework.ui.ModelMap
  它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）

• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，
  而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）
  它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。
  而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调整

• org.springframework.validation.Errors / org.springframework.validation.BindingResult
  为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面

• org.springframework.web.bind.support.SessionStatus
  可以通过该类型status对象显式结束表单的处理，这相当于触发session清除其中的通过@SessionAttributes定义的属性
  请求处理方法返回值的可选类型
  
• void
  此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：
  @RequestMapping(&quot;/welcome.do&quot;)
  public void welcomeHandler() {}
  对应的逻辑视图名为 “ welcome ” 

• String
  此时逻辑视图名为返回的字符，如以下的方法：
  @RequestMapping(method = RequestMethod.GET)
  public String setupForm(@RequestParam(&quot;ownerId&quot;) int ownerId, ModelMap model) {
      Owner owner = this.clinic.loadOwner(ownerId);
      model.addAttribute(owner);
      return &quot;ownerForm&quot;;
  }
  对应的逻辑视图名为 “ ownerForm ” 

• org.springframework.ui.ModelMap
  和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：
  @RequestMapping(&quot;/vets.do&quot;)
  public ModelMap vetsHandler() {
      return new ModelMap(this.clinic.getVets());
  }
  对应的逻辑视图名为“vets”，返回的ModelMap将被作为请求对应的模型对象，可以在JSP视图页面中访问到。

• ModelAndView
  当然还可以是传统的 ModelAndView 。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@RequestBody&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
 该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，
 例如application/json, application/xml等；
 
 它是通过使用HandlerAdapter配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。
 
 因为配置有FormHttpMessageConverter，所以也可以用来处理application/x-www-form-urlencoded的内容，
 处理完的结果放在一个MultiValueMap&amp;lt;String, String&amp;gt;里，这种情况在某些特殊需求下使用，
 详情查看FormHttpMessageConverter api;	
 
 .例如
 @RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)  
 public void handle(@RequestBody String body, Writer writer) 
 	throws IOException { 
  		writer.write(body);  
 }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@ModelAttribute&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 作用域：request
• 例如
  @RequestMapping(&quot;/base/userManageCooper/init.do&quot;)
  public String handleInit(@ModelAttribute(&quot;queryBean&quot;) ManagedUser sUser,Model model){
  • 或者
  @ModelAttribute(&quot;coopMap&quot;)// 将coopMap 返回到页面
  public Map&amp;lt;Long,CooperatorInfo&amp;gt; coopMapItems(){}

• 说明
  @ModelAttribute 声明在属性上，表示该属性的value 来源于model里&quot;queryBean&quot; ，并被保存到model里
  @ModelAttribute 声明在方法上，表示该方法的返回值被保存到model里
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@SessionAttributes&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 说明
  Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，
  以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。
  这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。
  
  @SessionAttributes 只能声明在类上，而不能声明在方法上。 
  • 例如
  @SessionAttributes(&quot;currUser&quot;) // 将ModelMap 中属性名为currUser 的属性
  @SessionAttributes({&quot;attr1&quot;,&quot;attr2&quot;})
  @SessionAttributes(types = User.class)
  @SessionAttributes(types = {User.class,Dept.class})
  @SessionAttributes(types = {User.class,Dept.class},value={&quot;attr1&quot;,&quot;attr2&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Controller&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如
@Controller
public class SoftCreateController extends SimpleBaseController {}
或者
@Controller(&quot;softCreateController&quot;)

说明
@Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@ResponseBody&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，
 写入到Response对象的body数据区。
 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；

.例如
 @RequestMapping(value = &quot;feedback/submit&quot;, method = { RequestMethod.POST })
 @ResponseBody
 public String submitSuggestion(@RequestBody(required = false) String requestBody) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Service&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如
@Service
public class SoftCreateServiceImpl implements ISoftCreateService {}
或者
@Service(&quot;softCreateServiceImpl&quot;)

说明
@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Autowired&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如
@Autowired
private ISoftPMService softPMService;
或者
@Autowired(required=false)
private ISoftPMService softPMService = new SoftPMServiceImpl();

说明
@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。
与@Resource的区别在于，@Resource允许通过bean名称或bean类型两种方式进行查找
@Autowired(required=false) 表示，如果spring上下文中没有找到该类型的bean时，
才会使用new SoftPMServiceImpl();

@Autowired 标注作用于Map类型时，如果Map的key为String类型，则Spring会将容器中所有类型符合Map的
value对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。

@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、
ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring
会自动注入这些实现类的实例，不需要额外的操作。

default-autowire属性取值如下：	
byType：按类型装配，可以根据属性的类型，在容器中寻找根该类型匹配的bean.如果发现多个，那么将会抛出异常。如果没有找到，即属性值为null。
byName：按名称装配，可以根据属性的名称，在容器中寻找根该属性名相同的bean,如果没有找到，即属性值为null。
Constructor与byType的方式类似，不同之处在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一致的bean,那么将会抛出异常。
Autodetect：通过bean类的自省机制来决定是使用constructor还是byType方式进行自动装配。如果发现默认的构造器，那么将使用byType方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Cacheable和@CacheFlush&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• @Cacheable ：声明一个方法的返回值应该被缓存
  例如：@Cacheable(modelId = &quot;testCaching&quot;)

• @CacheFlush ：声明一个方法是清空缓存的触发器
  例如：@CacheFlush(modelId = &quot;testCaching&quot;)

• 说明
  要配合缓存处理器使用，参考： http://hanqunfeng.iteye.com/blog/603719
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Resource&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @Resource
  private DataSource dataSource; // inject the bean named &#39;dataSource&#39;

  • 或者
	@Resource(name=&quot;dataSource&quot;)
	@Resource(type=DataSource.class)

• 说明
  @Resource 默认按bean的name 进行查找，如果没有找到会按type 进行查找，
  此时与@Autowired 类似
  在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、
  ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、
  MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。
  此时 name 属性不需要指定 ( 或者指定为&quot;&quot;)，否则注入失败；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@PostConstruct 和@PreDestroy&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• @PostConstruct
  在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执行
 （注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入）)。

• @PreDestroy
  在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@repository&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@component （不推荐使用)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• @component

  @component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式：  
  @repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。
  
  目前版本（2.5 ）中，这些注解与@component 的语义是一样的，完全通用， 在Spring以后的版本中可能
  会给它们追加更多的语义。推荐使用@repository、@Service、@Controller 来替代@component 。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@scope&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @Scope(&quot;session&quot;)
  @Repository()
  public class UserSessionBean implementsSerializable {}

• 说明
  在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，
  同样可以通过@scope 注解来完成

   @Scope中可以指定如下值：
   singleton:定义bean的范围为每个spring容器一个实例（默认值）
   prototype:定义bean可以被多次实例化（使用一次就创建一次）
   request:定义bean的范围是http请求（springMVC中有效）
   session:定义bean的范围是http会话（springMVC中有效）
   global-session:定义bean的范围是全局http会话（portlet中有效）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@InitBinder&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 说明
  如果希望某个属性编辑器仅作用于特定的 Controller ，
  可以在 Controller 中定义一个标注 @InitBinder 注解的方法，
  可以在该方法中向 Controller 了注册若干个属性编辑器

• 例如
  @InitBinder
  public void initBinder(WebDataBinder binder) {
      SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
      dateFormat.setLenient(false);
      binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Required&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @required              
  public  setName(String name){} 

• 说明
  @ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 
  的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 
  @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，
  而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非setXxxx() 类型的方法则被忽略。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@qualifier&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @Autowired
  @Qualifier(&quot;softService&quot;)
  private ISoftPMService softPMService; 
  
• 说明
  使用@Autowired 时，如果找到多个同一类型的bean，则会抛异常，此时可以使用 @Qualifier(&quot;beanName&quot;)，
  明确指定bean的名称进行注入，此时与 @Resource指定name属性作用相同。
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.io/2016/12/05/spring-annotation</link>
                <guid>http://username.github.io/2016/12/05/spring-annotation</guid>
                <pubDate>Mon, 05 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>SpringMVC框架理解</title>
                <description>
&lt;p&gt;Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。&lt;/p&gt;

&lt;p&gt;Spring的MVC框架主要由前端控制器(DispatcherServlet)、(处理器映射)HandlerMapping、控制器(Handler或Controller)、处理器适配器(HandlerAdapter或Service)、(视图解析器)View Resolver、(视图)View组成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/_images/spring3.jpg?raw=true&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;客户端请求提交到DispatcherServlet&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet将请求提交到Controller&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Controller调用业务逻辑处理后，返回ModelAndView&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视图负责将结果显示到客户端&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;springmvc&quot;&gt;SpringMVC组件&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DispatcherServlet是整个Spring MVC的核心。所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。其主要工作有以下三项：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;截获符合特定格式的URL请求。&lt;/li&gt;
  &lt;li&gt;初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。&lt;/li&gt;
  &lt;li&gt;初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能够完成客户请求到Controller映射。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。&lt;/p&gt;

&lt;p&gt;Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。&lt;/p&gt;

&lt;p&gt;从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。&lt;/p&gt;

&lt;h2 id=&quot;springmvc-1&quot;&gt;SpringMVC注解&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;@Controller&lt;/p&gt;

    &lt;p&gt;负责注册一个bean 到spring 上下文中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@Service&lt;/p&gt;

    &lt;p&gt;服务层组件，用于标注业务层组件,表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@RequestMapping&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　注解为控制器指定可以处理哪些 URL 请求&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@RequestBody&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ResponseBody&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ModelAttribute 　　　&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法&lt;/p&gt;

&lt;p&gt;　在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@RequestParam　&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@PathVariable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　绑定 URL 占位符到入参&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ExceptionHandler&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　注解到方法上，出现异常时会执行该方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ControllerAdvice&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常&lt;/p&gt;
</description>
                <link>http://username.github.io/2016/12/01/springmvc</link>
                <guid>http://username.github.io/2016/12/01/springmvc</guid>
                <pubDate>Thu, 01 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Spring AOP介绍</title>
                <description>
&lt;p&gt;AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。&lt;/p&gt;

&lt;p&gt;AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。&lt;/p&gt;

&lt;p&gt;使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。&lt;/p&gt;

&lt;p&gt;下面引用逗逼网友的通俗解释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aop切面编程就是在常规的执行java类中方法前或执行后加入自定义的方法。比如你本来每天都去打酱油，去，
打酱油，回。现在我每天在你打酱油路上等着，你去打酱油的时候我打你一顿，回来的时候给你点糖果吃。
你根本不知道为什么我会在路上拦住打你。所以在切面中插入你自定义的方法，这个方法的执行和本身要执行的
类方法无关系，也就是不是这个类的方法来调用你写的方法的，你写的方法什么时候执行都是要通过在配置指定。
我打完你，你该打酱油还是去打酱油，当然我如果是拦住你让你酱油打少点，你打酱油的时候还是会打那么多，
但是在你打完酱油回来的时候我可以把你的酱油倒些出去，所以嵌入的自定义方法对要调用的类方法本身没有影响，
但是可以操纵这个方法的返结果或者处理结果。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AOP核心概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、横切关注点&lt;/p&gt;

&lt;p&gt;对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点&lt;/p&gt;

&lt;p&gt;2、切面（aspect）&lt;/p&gt;

&lt;p&gt;类是对物体特征的抽象，切面就是对横切关注点的抽象&lt;/p&gt;

&lt;p&gt;3、连接点（joinpoint）&lt;/p&gt;

&lt;p&gt;被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器&lt;/p&gt;

&lt;p&gt;4、切入点（pointcut）&lt;/p&gt;

&lt;p&gt;对连接点进行拦截的定义&lt;/p&gt;

&lt;p&gt;5、通知（advice）&lt;/p&gt;

&lt;p&gt;所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类&lt;/p&gt;

&lt;p&gt;6、目标对象&lt;/p&gt;

&lt;p&gt;代理的目标对象&lt;/p&gt;

&lt;p&gt;7、织入（weave）&lt;/p&gt;

&lt;p&gt;将切面应用到目标对象并导致代理对象创建的过程&lt;/p&gt;

&lt;p&gt;8、引入（introduction）&lt;/p&gt;

&lt;p&gt;在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AOP使用场景&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AOP用来封装横切关注点，具体可以在下面的场景中使用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Authentication 权限&lt;/li&gt;
  &lt;li&gt;Caching 缓存&lt;/li&gt;
  &lt;li&gt;Context passing 内容传递&lt;/li&gt;
  &lt;li&gt;Error handling 错误处理&lt;/li&gt;
  &lt;li&gt;Lazy loading　懒加载&lt;/li&gt;
  &lt;li&gt;Debugging　　调试&lt;/li&gt;
  &lt;li&gt;logging, tracing, profiling and monitoring　记录跟踪　优化　校准&lt;/li&gt;
  &lt;li&gt;Performance optimization　性能优化&lt;/li&gt;
  &lt;li&gt;Persistence　　持久化&lt;/li&gt;
  &lt;li&gt;Resource pooling　资源池&lt;/li&gt;
  &lt;li&gt;Synchronization　同步&lt;/li&gt;
  &lt;li&gt;Transactions 事务&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何使用Spring AOP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以通过配置文件或者编程的方式来使用Spring AOP。&lt;/p&gt;

&lt;p&gt;配置可以通过xml文件来进行，大概有四种方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 基于代理的AOP(配置ProxyFactoryBean，显式地设置advisors, advice, target等)
或AutoProxyCreator(这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象)
2. 纯POJO切面(通过&amp;lt;aop:config&amp;gt;来配置)
3. @AspectJ注解驱动的切面(通过&amp;lt;aop:aspectj-autoproxy&amp;gt;来配置，使用AspectJ的注解来标识通知及切入点)
4. 注入式AspectJ切面
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;基于代理的AOP&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Spring支持五种类型的通知：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Before(前)  org.apringframework.aop.MethodBeforeAdvice&lt;/li&gt;
  &lt;li&gt;After-returning(返回后) org.springframework.aop.AfterReturningAdvice&lt;/li&gt;
  &lt;li&gt;After-throwing(抛出后) org.springframework.aop.ThrowsAdvice&lt;/li&gt;
  &lt;li&gt;Arround(周围) org.aopaliance.intercept.MethodInterceptor&lt;/li&gt;
  &lt;li&gt;Introduction(引入) org.springframework.aop.IntroductionInterceptor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建通知：实现这几个接口，把其中的方法实现了&lt;/li&gt;
  &lt;li&gt;定义切点和通知者：在Spring配制文件中配置这些信息&lt;/li&gt;
  &lt;li&gt;使用ProxyFactoryBean来生成代理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;接口
public interface Eatable {
	void eat(); 
}
	
目标类
public Human implements Eatable {
	public void eat(){
  		System.out.println(&quot;吃饭&quot;);
  	}
}
applicationContext.xml中配置目标类
&amp;lt;bean id=&quot;human&quot; class=&quot;com.test.aop.bean.Human&quot;&amp;gt;
  	
通知类
public class EatHelper implements MethodBeforeAdvice,AfterReturningAdvice {
	public void before(Method mtd, Object[] arg1, Object arg2)
    	throws Throwable {
    		System.out.println(&quot;饭前洗手&quot;);
	}

	public void afterReturning(Object arg0, Method arg1, Object[] arg2,
        Object arg3) throws Throwable {
    		System.out.println(&quot;饭后漱口&quot;);
	}
}
	
applicationContext.xml中配置通知bean
&amp;lt;bean id=&quot;eatHelper&quot; class=&quot;com.test.aop.bean.EatHelper&quot;&amp;gt;&amp;lt;/bean&amp;gt;
	
配置切点
&amp;lt;bean id=&quot;eatPointcut&quot; class=&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;&amp;gt;
	&amp;lt;property name=&quot;pattern&quot; value=&quot;.*eat&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
	
结合通知和切点
&amp;lt;bean id=&quot;eatHelperAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&amp;gt;
	&amp;lt;property name=&quot;advice&quot; ref=&quot;eatHelper&quot;/&amp;gt;
 	&amp;lt;property name=&quot;pointcut&quot; ref=&quot;eatPointcut&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
 	
调用ProxyFactoryBean产生代理对象
&amp;lt;bean id=&quot;humanProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&amp;gt;
 	&amp;lt;property name=&quot;target&quot; ref=&quot;human&quot;/&amp;gt;
 	&amp;lt;property name=&quot;interceptorNames&quot; value=&quot;eatHelperAdvisor&quot; /&amp;gt;
 	&amp;lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.test.aop.bean.Eatable&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
ProxyFactoryBean是一个代理，我们可以把它转换为proxyInterfaces中指定的实现该interface的代理对象
	
测试
public class Test {
	public static void main(String[] args){
   		ApplicationContext appCtx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
   		Eatable eater = (Eatable)appCtx.getBean(&quot;humanProxy&quot;);
   		eater.eat();
	}
}
	
结果：
	饭前洗手
	吃饭
	饭后漱口
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置切点跟通知的地方,Spring提供了一种自动代理的功能，能让切点跟通知自动进行匹配，修改配置文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;bean id=&quot;eatHelper&quot; class=&quot;com.test.aop.bean.EatHelper&quot;&amp;gt;&amp;lt;/bean&amp;gt;
 &amp;lt;bean id=&quot;human&quot; class=&quot;com.test.aop.bean.Human&quot;&amp;gt;
 &amp;lt;bean id=&quot;eatHelperAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&amp;gt;
	&amp;lt;property name=&quot;advice&quot; ref=&quot;eatHelper&quot;/&amp;gt;
 	&amp;lt;property name=&quot;pattern&quot; value=&quot;.*eat&quot;/&amp;gt;
 &amp;lt;/bean&amp;gt;
 &amp;lt;bean id=&quot;human&quot; class=&quot;com.test.aop.bean.Human&quot;&amp;gt;&amp;lt;/bean&amp;gt;
 &amp;lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&amp;gt;

 声明了DefaultAdvisorAutoProxyCreator就能为方法匹配的bean自动创建代理。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@AspectJ提供的注解&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Aspect   // 标识切面
public class EatHelper {
	public EatHelper(){}

	@Pointcut(&quot;execution(* *.eat())&quot;)  // 指定切点
	public void eatPoint(){}

	@Before(&quot;eatPoint()&quot;)   // 指定运行时通知
	public void beforeEat(){
    	System.out.println(&quot;饭前洗手!&quot;);
	}

	@AfterReturning(&quot;eatPoint()&quot;)  // 指定运行时通知
	public void afterEat(){
    	System.out.println(&quot;饭后漱口!&quot;);
	}
}

// 配置applicationContext.xml
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop
					http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;


然后加上这个标签:
&amp;lt;aop:aspectj-autoproxy/&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;纯粹的POJO切面(最常用的方法)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring在aop的命名空间里面还提供的配置元素:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;aop:aspectj-autoproxy /&gt;
    &lt;aop:advisor&gt; 定义一个AOP通知者
&lt;/aop:advisor&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:after&gt; 后通知
&lt;/aop:after&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:after-returning&gt; 返回后通知
&lt;/aop:after-returning&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:after-throwing&gt; 抛出后通知
&lt;/aop:after-throwing&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:around&gt; 周围通知
&lt;/aop:around&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:aspect&gt;定义一个切面
&lt;/aop:aspect&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:before&gt;前通知
&lt;/aop:before&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:config&gt;顶级配置元素，类似于&lt;beans&gt;这种东西
&lt;/beans&gt;&lt;/aop:config&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:pointcut&gt;定义一个切点

&lt;/aop:pointcut&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码不变，只是修改配置文件,加入AOP配置即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;aop:config&amp;gt;
	&amp;lt;aop:aspect ref=&quot;eatHelper&quot;&amp;gt;
		&amp;lt;aop:before method=&quot;beforeEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
		&amp;lt;aop:after method=&quot;afterEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
	&amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如增加一个打印日志的横切关注点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LogHandler {
	public void LogBefore() {
    	System.out.println(&quot;Log before method&quot;);
	}
	
	public void LogAfter() {
    	System.out.println(&quot;Log after method&quot;);
	}
}

applicationContext.xml配置文件需要修改

&amp;lt;bean id=&quot;logHandler&quot; class=&quot;com.test.aop.LogHandler&quot; /&amp;gt;
    
&amp;lt;aop:config&amp;gt;
	&amp;lt;aop:aspect id=&quot;eat&quot; ref=&quot;eatHelper&quot; order=&quot;1&quot;&amp;gt;
		&amp;lt;aop:before method=&quot;beforeEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
		&amp;lt;aop:after method=&quot;afterEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
	&amp;lt;/aop:aspect&amp;gt;
    &amp;lt;aop:aspect id=&quot;log&quot; ref=&quot;logHandler&quot; order=&quot;2&quot;&amp;gt;
    	&amp;lt;aop:pointcut id=&quot;printLog&quot; expression=&quot;execution(* com.test.aop.Eatable.*(..))&quot; /&amp;gt;
        &amp;lt;aop:before method=&quot;LogBefore&quot; pointcut-ref=&quot;printLog&quot; /&amp;gt;
        &amp;lt;aop:after method=&quot;LogAfter&quot; pointcut-ref=&quot;printLog&quot; /&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要想让logHandler在eatHelper前使用有两个办法：&lt;/p&gt;

&lt;p&gt;（1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序&lt;/p&gt;

&lt;p&gt;（2）把logHandler定义在eatHelper前面，Spring默认以aspect的定义顺序作为织入顺序&lt;/p&gt;

</description>
                <link>http://username.github.io/2016/12/01/spring-aop</link>
                <guid>http://username.github.io/2016/12/01/spring-aop</guid>
                <pubDate>Thu, 01 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Spring框架IOC/DI</title>
                <description>
&lt;p&gt;Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。&lt;/p&gt;

&lt;p&gt;Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/spring1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。&lt;/p&gt;

&lt;h2 id=&quot;iocdi&quot;&gt;控制反转(IOC/DI)&lt;/h2&gt;

&lt;p&gt;控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。原因就是java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object() 这样的语法来完成合作对象的申请工作。这样做的结果就是对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）。&lt;/p&gt;

&lt;p&gt;在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。下表列出了 IOC 的一个实现模式。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;类型 1	服务需要实现专门的接口，通过接口，由对象提供这些服务，可以从对象查询依赖性（例如，需要的附加服务）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型 2	通过 JavaBean 的属性（例如 setter 方法）分配依赖性 (设置注入)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型 3	依赖性以构造函数的形式提供，不以 JavaBean 属性的形式公开 （构造注入）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 框架的 IOC 容器采用类型 2 和类型3 实现。&lt;/p&gt;

&lt;p&gt;引用网友的通俗解释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先想说说IoC（Inversion of Control，控制倒转和DI依赖注入是一个概念）。这是spring的核心，贯穿始终。
所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，
举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她
们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂
深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就
必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象
始终会和其他的接口或类藕合起来。

那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了
很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像
林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，
我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过
程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类
都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时
候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，
也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，
现在是所有对象都被spring控制，所以这叫控制反转。如果你还不明白的话，我决定放弃。

IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency 
Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个
Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection
怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针
一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个
Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后
一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的
属性，spring就是通过反射来实现注入的。关于反射的相关资料请查阅java doc。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ioc-&quot;&gt;IOC 容器&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;BeanFactory&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Spring 设计的核心是 org.springframework.beans 包，它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是 BeanFactory 接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/_images/spring2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;spring提供了许多IOC容器的实现。比如XmlBeanFactory，ClasspathXmlApplicationContext等。
其中XmlBeanFactory就是针对最基本的ioc容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述），ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。从ApplicationContext接口的实现，我们看出其特点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.  支持信息源，可以实现国际化。（实现MessageSource接口） 

2.  访问资源。(实现ResourcePatternResolver接口，这个后面要讲)

3.  支持应用事件。(实现ApplicationEventPublisher接口)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;BeanDefinition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的。
Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;接口Animal

public interface Animal {
    public void say();   
}

接口实现类

public class Cat implements Animal {  
	private String name;  
	public void say() {  
    	System.out.println(&quot;I am &quot; + name + &quot;!&quot;);  
	}  
	public void setName(String name) {  
    	this.name = name;  
	}  
}  

applicationContext.xml bean定义


&amp;lt;bean id=&quot;animal&quot; class=&quot;phz.springframework.test.Cat&quot;&amp;gt;  
    &amp;lt;property name=&quot;name&quot; value=&quot;kitty&quot; /&amp;gt;  
&amp;lt;/bean&amp;gt; 

测试

public static void main(String[] args) {  
    ApplicationContext context = new FileSystemXmlApplicationContext(  
            &quot;applicationContext.xml&quot;);  
    Animal animal = (Animal) context.getBean(&quot;animal&quot;);  
    animal.say();  
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出I am kitty!&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;http://projects.spring.io/spring-framework/&lt;/p&gt;
</description>
                <link>http://username.github.io/2016/11/29/spring</link>
                <guid>http://username.github.io/2016/11/29/spring</guid>
                <pubDate>Tue, 29 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Apache Tomcat 安全配置</title>
                <description>
&lt;h2 id=&quot;telnet&quot;&gt;telnet管理端口保护&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改默认的 8005 管理端口为不易猜测的端口（大于 1024）；
修改 SHUTDOWN指令为其他字符串；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(server.xml)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Server port=&quot;8520&quot; shutdown=&quot;dangerous&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ajp&quot;&gt;ajp连接端口保护&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改默认的 ajp 8009 端口为不易冲突的大于1024 端口；
通过 iptables 规则限制ajp 端口访问的权限仅为线上机器(可选)；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(server.xml)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Connector port=&quot;8521&quot; protocol=&quot;AJP/1.3&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;禁用管理端&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;删除默认的{Tomcat安装目录}/conf/tomcat-users.xml 文件，重启 tomcat后将会自动生成新的文件；
删除{Tomcat 安装目录}/webapps 下默认的所有目录和文件；
将 tomcat 应用根目录配置为 tomcat 安装目录以外的目录；
热部署可以关掉，防止被黑客注入木马程序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;降权启动&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tomcat 启动用户权限必须为非 root 权限，尽量降低 tomcat 启动用户的目录访问权限；
如需直接对外使用 80端口，可通过普通账号启动后，配置 iptables规则进行转发；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;无
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;文件列表访问控制&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.conf/web.xml 文件中default 部分 listings 的配置必须为 false；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;init-param&amp;gt; 
	&amp;lt;param-name&amp;gt;listings&amp;lt;/param-name&amp;gt; 
	&amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt; 
&amp;lt;/init-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;web-inf-&quot;&gt;WEB-INF 目录访问控制&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tomcat web 目录里的 WEB-INF 目录默认为禁止访问，但是当tomcat 组合其他webserver 一起使用，并且其他 webserver 和tomcat 指向同一目录时，需要在其他webserver 配置文件里添加禁止访问/WEB-INF 目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Apache：
&amp;lt;Directory &quot;WEB-INF&quot;&amp;gt;
	Order allow,deny
	Deny from all
&amp;lt;/Directory&amp;gt;

Nginx：
location ^~ /WEB-INF
{
 		deny all;
}

Lighttpd:
$HTTP[&quot;url&quot;] =~ &quot;^/WEB-INF/&quot; {
 		url.access-deny = ( &quot;&quot; )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;版本信息隐藏&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改conf/web.xml，重定向 403、404 以及 500等错误到指定的错误页面(全局)；

也可以通过修改应用程序目录下的WEB-INF/web.xml下的配置进行错误页面的重定向（应用级别）；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;error-page&amp;gt;
	&amp;lt;error-code&amp;gt;403&amp;lt;/error-code&amp;gt;
	&amp;lt;location&amp;gt;/forbidden.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&amp;lt;error-page&amp;gt;
	&amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
	&amp;lt;location&amp;gt;/notfound.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&amp;lt;error-page&amp;gt;
	&amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt;
	&amp;lt;location&amp;gt;/systembusy.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;server-header&quot;&gt;Server header重写&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在 HTTP Connector 配置中加入 server 的配置；

当 tomcat HTTP 端口直接提供 web服务时此配置生效，加入此配置，将会替换 http 响应Server header部分的默认配置，默认是Apache-Coyote/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(conf/server.xml)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot;
           server=&quot;webserver&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;访问限制&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;通过配置，限定访问的 ip 来源
通过配置信任ip 的白名单，拒绝非白名单 ip的访问，此配置主要是针对高保密级别的系统，一般产品线不需要；
Tomcat供了两个参数供你配置：RemoteHostValve 和RemoteAddrValve，前者用于限制主机名，后者用于限制IP地址。
重启生效
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(conf/server.xml新增一条)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;全局设置（对Tomcat下所有应用生效）
&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
	&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;68.147.18.138,68.135.165.*&quot; deny=&quot;*.*.*.*&quot;/&amp;gt;
	#&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteHostValve&quot; allow=&quot;abc.com&quot; deny=&quot;&quot;/&amp;gt;
&amp;lt;/Host&amp;gt;
 

局部设置 (仅对具体的应用生效)
&amp;lt;Context path=&quot;/test&quot; docBase=&quot;/home/work/tomcat/webapps/test&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; crossContext=&quot;true&quot;&amp;gt;
&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;68.147.18.138,68.135.165.*&quot; deny=&quot;*.*.*.*&quot;/&amp;gt;
&amp;lt;/Context&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;起停脚本权限回收&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;去除其他用户对 Tomcat的 bin 目录下shutdown.sh、startup.sh、catalina.sh 的可执行权限；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod -R 744 tomcat/bin/* 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;访问日志格式规范&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;开启 Tomcat默认访问日志中的Referer 和User-Agent记录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例（conf/server.xml）&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;全局设置
&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
	&amp;lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t %r %s %b %{Referer}i %{User-Agent}i %D&quot; resolveHosts=&quot;false&quot;/&amp;gt;
&amp;lt;/Host&amp;gt;
局部设置
参考上面的访问限制小节
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.io/2016/11/27/apache-tomcat</link>
                <guid>http://username.github.io/2016/11/27/apache-tomcat-</guid>
                <pubDate>Sun, 27 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Java中日期问题总结</title>
                <description>
&lt;p&gt;由于在写程序的过程中，经常遇到日期的转换，为此通过参考网上的几篇总结，记录下自己需要的问题，以备后用，本文讨论的主要是关于Java API 中 Date, Calendar, TimeZone和DateFormat的使用，和时区的转换问题。&lt;/p&gt;

&lt;h2 id=&quot;date&quot;&gt;Date&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要说明的是 Date 无时区，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;date.toString() 则是按当前 JVM 的默认时区来格式化的，也就是 TimeZone.getDefault() 获得的时区，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同时 date.toString() 是按照 “EEE MMM dd HH:mm:ss zzz yyyy” 来格式化的；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类Date表示特定的瞬间，精确到毫秒。获得一个表示当前时间的Date对象有两种方式：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Date date = new Date();  
Date date = Calendar.getInstance().getTime(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Date对象本身所存储的毫秒数可以通过date.getTime()方法得到；该函数返回自1970年1月1日 00:00:00 GMT以来此对象表示的毫秒数。&lt;/p&gt;

&lt;p&gt;Calendar的getInstance()方法有参数为TimeZone和Locale的重载，可以使用指定时区和语言环境获得一个日历。无参则使用默认时区和语言环境获得日历。&lt;/p&gt;

&lt;h2 id=&quot;date-to-string&quot;&gt;Date to String&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);  
String strDate = format.format(date);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;string-to-date&quot;&gt;String to Date&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  
Date date = format.parse(strDate);	
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;时区转换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了克服时间上的混乱，1884年在华盛顿召开的一次国际经度会议（又称国际子午线会议[1]）上，规定将全球划分为24个时区（东、西各12个时区）。规定英国（格林尼治天文台旧址）为中时区（零时区）、东1-12区，西1-12区。每个时区横跨经度15度，时间正好是1小时。最后的东、西第12区各跨经度7.5度，以东、西经180度为界。每个时区的中央经线上的时间就是这个时区内统一采用的时间，称为区时，相邻两个时区的时间相差1小时。例如，中国东8区的时间总比泰国东7区的时间早1小时，而比日本东9区的时间迟1小时。因此，出国旅行的人，必须随时调整自己的手表，才能和当地时间相一致。凡向西走，每过一个时区，就要把表拨慢1小时（比如2点拨到1点）；凡向东走，每过一个时区，就要把表拨快1小时（比如1点拨到2点）。并且规定英国（格林尼治天文台旧址）为本初子午线，即零度经线。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GMT 0:00 格林尼治标准时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UTC +00:00 校准的全球时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UTC 是比 GMT 更加精确的世界时间标准，在不需要精确到秒的情况下，通常也将GMT和UTC视作等同；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CST 可以同时表示中国、美国、澳大利亚、古巴四个国家的标准时间；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;GMT时间：即格林威治平时（Greenwich Mean Time）。平太阳时是与视太阳时对应的，由于地球轨道非圆形，运行速度岁地球与太阳距离改变而出现变化，因此视太阳时欠缺均匀性。为了纠正这种不均匀性，天文学家计算地球非圆形轨迹与极轴倾斜对视太阳时的效应。平太阳时就是指经修订之后的视太阳时。在格林威治子午线上的平太阳时称为世界时（UTC），又叫格林威治平时（GMT）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;TimeZone&lt;/strong&gt;表示时区偏移量，本质上以毫秒数保存与GMT的差值。获取TimeZone可以通过时区ID，如”America/New_York”，也可以通过GMT+/-hh:mm来设定。例如北京时间可以表示为GMT+8:00。
TimeZone.getRawOffset()方法可以用来得到当前时区的标准时间到GMT的偏移量。上段提到的”America/New_York”和”GMT+8:00”两个时区的偏移量分别为-18000000和28800000。&lt;/p&gt;

&lt;p&gt;因此，时区转换的&lt;code&gt;原理&lt;/code&gt;就是：在时区间转换时间时，首先用原时间减掉原时间所在时区相对于GMT的偏移量，得到原时间相对与GMT的值，再加上目标时区相对GMT的偏移量即可。然后按照指定日期格式重新转换成Date对象。&lt;/p&gt;

&lt;p&gt;示例代码如下(东京时间转北京时间)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	public class DateTransformer
    {
		public static final String DATE_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
       
    	public static String dateTransformBetweenTimeZone(Date sourceDate, DateFormat formatter, TimeZone sourceTimeZone, TimeZone targetTimeZone) {
    		Long targetTime = sourceDate.getTime() - sourceTimeZone.getRawOffset() + targetTimeZone.getRawOffset();
        	return DateTransformer.getTime(new Date(targetTime), formatter);
    	}
       
    	public static String getTime(Date date, DateFormat formatter){
       		return formatter.format(date);
    	}
       
    	public static void main(String[] args){
    		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
    		Date date = Calendar.getInstance().getTime();
    		TimeZone srcTimeZone = TimeZone.getTimeZone(&quot;GMT+8&quot;);
    		TimeZone destTimeZone = TimeZone.getTimeZone(&quot;GMT+9&quot;);
    		System.out.println(DateTransformer.dateTransformBetweenTimeZone(date, formatter, srcTimeZone, destTimeZone));
    	}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;时间跳转&lt;/h2&gt;

&lt;p&gt;获取下一天的日期(示例)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calendar calendar = Calendar.getInstance();  
calendar.set(Calendar.YEAR, 2016);  
calendar.set(Calendar.MONTH, 11);  
calendar.set(Calendar.DAY_OF_MONTH, 25);  
  
SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);  
System.out.println(format.format(calendar.getTime())); // 2016-11-25  
calendar.add(Calendar.DAY_OF_MONTH, 1);                // 增加一天  
System.out.println(format.format(calendar.getTime())); // 2016-11-16 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取下一小时时间(示例)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calendar calendar = Calendar.getInstance();  
calendar.set(Calendar.YEAR, 2016);  
calendar.set(Calendar.MONTH, 11);  
calendar.set(Calendar.DAY_OF_MONTH, 25);  
calendar.set(Calendar.HOUR_OF_DAY, 11);  
  
SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  
System.out.println(format.format(calendar.getTime())); // 2016-11-25 11:46:38  
calendar.add(Calendar.HOUR_OF_DAY, 1);                 // 增加一个小时  
System.out.println(format.format(calendar.getTime())); // 2016-11-25 12:46:38
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dateformat&quot;&gt;DateFormat&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DateFormat是是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&amp;gt; 文本）、解析（文本-&amp;gt; 日期）和标准化。将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SimpleDateFormat则是一个以与语言环境有关的方式来格式化和解析日期的具体类，可以以“日期和时间模式”字符串指定日期和时间格式。我们函数中所用模式字符串为”yyyy-MM-dd HH:mm:ss”，则输出日期：”2013-07-16 00:00:00”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SimpleDateFormat format1 = new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss zzz yyyy&quot;, Locale.SIMPLIFIED_CHINESE);  
SimpleDateFormat format2 = new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss zzz yyyy&quot;, Locale.US);  
System.out.println(format1.format(new Date())); // 星期三 七月 17 10:57:50 CST 2013  
System.out.println(format2.format(new Date())); // Wed Jul 17 10:57:50 CST 2013 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他常见的模式字母定义如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;日期或时间元素&lt;/th&gt;
      &lt;th&gt;表示&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;G&lt;/td&gt;
      &lt;td&gt;Era 标志符&lt;/td&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;AD&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;y&lt;/td&gt;
      &lt;td&gt;年&lt;/td&gt;
      &lt;td&gt;Year&lt;/td&gt;
      &lt;td&gt;1996; 96&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;年中的月份&lt;/td&gt;
      &lt;td&gt;Month&lt;/td&gt;
      &lt;td&gt;July; Jul; 07&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;年中的周数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;月份中的周数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D&lt;/td&gt;
      &lt;td&gt;年中的天数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;189&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;月份中的天数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;月份中的星期&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;星期中的天数&lt;/td&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;Tuesday; Tue&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;Am/pm 标记&lt;/td&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;PM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;H&lt;/td&gt;
      &lt;td&gt;一天中的小时数（0-23）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;一天中的小时数（1-24）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;am/pm 中的小时数（0-11）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;h&lt;/td&gt;
      &lt;td&gt;am/pm 中的小时数（1-12）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;m&lt;/td&gt;
      &lt;td&gt;小时中的分钟数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;分钟中的秒数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;毫秒数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;978&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;z&lt;/td&gt;
      &lt;td&gt;时区&lt;/td&gt;
      &lt;td&gt;General time zone	Pacific Standard Time;&lt;/td&gt;
      &lt;td&gt;PST; GMT-08:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;时区&lt;/td&gt;
      &lt;td&gt;RFC 822 time zone&lt;/td&gt;
      &lt;td&gt;-0800&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
                <link>http://username.github.io/2016/11/25/java</link>
                <guid>http://username.github.io/2016/11/25/java</guid>
                <pubDate>Fri, 25 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>mysql主从复制</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;基本原理&lt;/h2&gt;

&lt;p&gt;mysql支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。mysql复制基于主服务器在二进制日志中跟踪所有对数据库的更改(更新、删除等等)。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收主服务器已经记录到其二进制日志的保存的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;本文实验环境如下：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;操作系统： centos 6.3&lt;/li&gt;
  &lt;li&gt;mysql版本： 5.5&lt;/li&gt;
  &lt;li&gt;master ip: 192.168.1.22&lt;/li&gt;
  &lt;li&gt;slave ip: 192.168.1.23&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mastermycnf&quot;&gt;修改主服务器master(my.cnf):&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    [mysqld]
    log-bin=mysql-bin         //[必须]启用二进制日志
    server-id=1               //[必须]服务器唯一ID，默认是1，一般取IP最后一段
    binlog-do-db=db_nameA     //指定对db_nameA记录二进制日志    
    binlog-ignore-db=db_namB  //指定不对db_namB记录二进制日志
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;slavemycnf&quot;&gt;修改从服务器slave(my.cnf):&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;	[mysqld]
    log-bin=mysql-bin   //[不是必须]启用二进制日志
    server-id=2         //[必须]服务器唯一ID，默认是1，一般取IP最后一段
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mysql&quot;&gt;重启两台服务器的mysql&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   /etc/init.d/mysql restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;slave&quot;&gt;在主服务器上建立帐户并授权slave:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; GRANT REPLICATION SLAVE ON *.* to &#39;replication&#39;@&#39;%&#39; identified by &#39;test@123&#39;; 
//一般不用root帐号，&#39;%&#39;表示所有客户端都可能连，只要帐号，密码正确，此处可用具体客户端IP代替，如192.168.1.22，加强安全。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mysqlmaster&quot;&gt;登录主服务器的mysql，查询master的状态&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show master status \G;
*************************** 1. row ***************************
  File: mysql-bin.000004
  Position: 257
  Binlog_Do_DB:
  Binlog_Ignore_DB:
  1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;slave-1&quot;&gt;配置从服务器Slave&lt;/h2&gt;

&lt;p&gt;第一种方式：使用change master to命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; change master to master_host=&#39;192.168.1.22&#39;,master_user=&#39;replication&#39;,master_password=&#39;test@123&#39;,master_log_file=&#39;mysql-bin.000004&#39;,master_log_pos=107;
mysql&amp;gt; start slave;    //启动从服务器复制功能
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种方式：修改my.cnf中字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# The replication master for this slave - required
#master-host     =   &amp;lt;hostname&amp;gt;
#
# The username the slave will use for authentication when connecting
# to the master - required
#master-user     =   &amp;lt;username&amp;gt;
#
# The password the slave will authenticate with when connecting to
# the master - required
#master-password =   &amp;lt;password&amp;gt;
#
# The port the master is listening on.
# optional - defaults to 3306
#master-port     =  &amp;lt;port&amp;gt;
#master_log_file = &amp;lt;log_file&amp;gt;
#master_log_pos  = &amp;lt;log_pos&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;检查从服务器复制功能状态&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show slave status \G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.1.22
                  Master_User: replication
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 257
               Relay_Log_File: 192.168.1.23-bin.000002
                Relay_Log_Pos: 403
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 257
              Relay_Log_Space: 569
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
1 row in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;注：Slave_IO及Slave_SQL进程必须正常运行，即YES状态，否则都是错误的状态(如：其中一个NO均属错误)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;主从服务器测试&lt;/h2&gt;

&lt;p&gt;在主服务器Mysql，新建立数据库demo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   mysql&amp;gt; create database demo default character set utf8 collate utf8_general_ci;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在主服务器Mysql查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   mysql&amp;gt; show databases;
   +--------------------+
   | Database           |
   +--------------------+
   | information_schema |
   | demo                |      //新建的
   | mysql                |
   | test                 |
   +--------------------+
   4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从服务器Mysql查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   mysql&amp;gt; show databases;
   +--------------------+
   | Database               |
   +--------------------+
   | information_schema |
   | demo                 |       //新建的
   | mysql                 |
   | test          |
   +--------------------+
   4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://username.github.io/2016/11/17/mysql</link>
                <guid>http://username.github.io/2016/11/17/mysql</guid>
                <pubDate>Thu, 17 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>mysql binlog入门</title>
                <description>
&lt;h1 id=&quot;binlog&quot;&gt;Binlog&lt;/h1&gt;

&lt;p&gt;二进制日志（BINLOG），记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但是不包括数据查询语句。语句以“事件”的形式保存，它描述了数据的更改过程。此日志对于灾难时的数据恢复起着极其重要的作用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;日志的位置和格式&lt;/h2&gt;

&lt;p&gt;当用–log-bin[=file_name]选项启动时，mysqld开始将数据变更情况写入日志文件。如果没有给出filename值，默认名为主机名后面跟“-bin”。如果给出了文件名，但没有包含路径，则文件默认被写入参数DATADIR（数据目录）指定的目录（重启mysql一次将会自动生成一个新的binlog）。&lt;/p&gt;

&lt;p&gt;开启状态的查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &#39;%log_bin%&#39;;
+---------------------------------+-------+
| Variable_name                   | Value |
+---------------------------------+-------+
| log_bin                         | ON    |
| log_bin_trust_function_creators | OFF   |
| log_bin_trust_routine_creators  | OFF   |
| sql_log_bin                     | ON    |
+---------------------------------+-------+
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MySQL 5.5中，二进制日志的格式分为3种：STATEMENT、ROW、MIXED，可以在启动时通过参数–binlog_format进行设置，这三种日志格式区别如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Statement&lt;/code&gt;：每一条会修改数据的sql都会记录在binlog中。&lt;/p&gt;

&lt;p&gt;优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入，row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)&lt;/p&gt;

&lt;p&gt;缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).&lt;/p&gt;

&lt;p&gt;使用以下函数的语句也无法被复制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LOAD_FILE()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UUID()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;USER()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FOUND_ROWS()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时在INSERT …SELECT 会产生比 RBR 更多的行级锁&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Row&lt;/code&gt;：不记录sql语句上下文相关信息，仅保存哪条记录被修改。&lt;/p&gt;

&lt;p&gt;优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题&lt;/p&gt;

&lt;p&gt;缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Mixedlevel&lt;/code&gt;： 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二进制日志的管理&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;开启二进制日志配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;方法一、修改my.cnf参数文件，该方法需要重启&lt;/p&gt;

&lt;p&gt;log-bin = mysql-bin #打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径，如：/home/www/mysql_bin_log/mysql-bin&lt;/p&gt;

&lt;p&gt;关闭二进制日志的方法：log-bin = mysql-bin注释掉即可&lt;/p&gt;

&lt;p&gt;方法二、不重启修改二进制日志配置，该方法mysql的版本需要5.6以上&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SET @@global.log_bin=1&lt;/td&gt;
      &lt;td&gt;0  （1为开启，0为关闭）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;SET @@global.binlog_size=37268(单位bytes)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;暂停二进制日志&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SET sql_log_bin={0&lt;/td&gt;
      &lt;td&gt;1}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;修改二进制日志的大小&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;修改my.cnf参数文件中的max_binlog_size的值；&lt;/p&gt;

&lt;p&gt;说明：如果你的二进制文件的大小超过了max_binlog_size，它就是自动创建新的二进制文件。当然如果恰好在日志文件到达它的最大尺寸时写入了大的事务，那么日志文件还是会超过max_binlog_size的大小&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进行二进制日志的切换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下当二进制日志写满了或者数据库重启了才会进行切换，但是也可以手工的进行切换的动作&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; flush logs;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其他参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;binlog-cache-size=100m 设置二进制日志缓存大小&lt;/p&gt;

&lt;p&gt;sync-binlog=N（每个N秒将缓存中的二进制日志记录写回硬盘，默认值为0。不过，你经常会陷入group commit函数与I/O之间二选一的矛盾。如果在replication环境中，由于考虑到耐久性与一致性，则需要设置1。同时，还需要设置innodb_flush_log_at_trx_commit=1以及innodb-support-xa=1默认开启；）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二进制日志的读取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shell&amp;gt; mysqlbinlog log-file
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;二进制日志的删除&lt;/h2&gt;

&lt;p&gt;对于比较繁忙的OLTP（在线事务处理）系统，由于每天生成日志量大，这些日志如果长时间不清除，将对磁盘空间带来很大的浪费。因此，定期删除日志是DBA维护MYSQL数据库的一个重要工作内容。下面将介绍几种删除日志的常见方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行RESET MASTER命令，该命令将删除所有BINLOG日志，新日志编号从“000001”开始，hostname-bin.index是日志的索引文件，记录了最大的日志序号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行PURGE MASTER LOGS TO “mysql-bin.&lt;strong&gt;**&lt;/strong&gt;“命令，该命令将删除“&lt;strong&gt;**&lt;/strong&gt;”编号之前的所有日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法三&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行PURGE MASTER LOGS BEFORE ‘yyyy-mm-dd hh24:mi:ss’命令，该命令将删除日期为“yyyy-mm-dd hh24:mi:ss”之前产生的所有日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法四&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在my.cnf的[mysqld]中设置参数–expire_logs_days=#，此参数的含义是设置日志的过期天数，过了指定的天数后日志将会被自动删除，这样将有利于减少DBA管理日志的工作量。&lt;/p&gt;
</description>
                <link>http://username.github.io/2016/11/08/mysql-binlog</link>
                <guid>http://username.github.io/2016/11/08/mysql-binlog</guid>
                <pubDate>Tue, 08 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Apache和Nginx的rewrite规则浅析</title>
                <description>
&lt;h2 id=&quot;nginx-rewrite&quot;&gt;Nginx Rewrite规则相关指令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Nginx Rewrite规则相关&lt;code&gt;指令&lt;/code&gt;有&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;if        #条件判断&lt;/p&gt;

&lt;p&gt;rewrite   #跳转&lt;/p&gt;

&lt;p&gt;set       #对变量进行了赋值操作&lt;/p&gt;

&lt;p&gt;return    #该指令将结束执行直接返回http状态码到客户端&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nginx Rewrite规则相关&lt;code&gt;标记&lt;/code&gt;有&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;redirect   #返回302临时重定向 地址栏会显示跳转后的地址&lt;/p&gt;

&lt;p&gt;last       #相当于Apache里的[L]标记，表示完成rewrite（重新将rewrite后的地址在server标签中执行）&lt;/p&gt;

&lt;p&gt;break      #终止匹配, 不再匹配后面的规则（将rewrite后的地址在当前location标签中执行）&lt;/p&gt;

&lt;p&gt;permanent  #返回301永久重定向 地址栏会显示跳转后的地址&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个简单的Nginx Rewrite规则语法如下&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rewrite ^/b/(.*)\.html /play.php?video=$1 break;
如果加上if语句，示例如下： 
if (!-f $request_filename)
{ rewrite ^/img/(.*)$ /site/$host/_images/$1 last;      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Nginx rewrite模块环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$args, 请求中的参数;&lt;/p&gt;

&lt;p&gt;$content_length, HTTP请求信息里的”Content-Length”;&lt;/p&gt;

&lt;p&gt;$content_type, 请求信息里的”Content-Type”;&lt;/p&gt;

&lt;p&gt;$document_root, 针对当前请求的根路径设置值;&lt;/p&gt;

&lt;p&gt;$document_uri, 与$uri相同;&lt;/p&gt;

&lt;p&gt;$host, 请求信息中的”Host”，如果请求中没有Host行，则等于设置的服务器名;&lt;/p&gt;

&lt;p&gt;$limit_rate, 对连接速率的限制;&lt;/p&gt;

&lt;p&gt;$request_method, 请求的方法，比如”GET”、”POST”等;&lt;/p&gt;

&lt;p&gt;$remote_addr, 客户端地址;&lt;/p&gt;

&lt;p&gt;$remote_port, 客户端端口号;&lt;/p&gt;

&lt;p&gt;$remote_user, 客户端用户名，认证用;&lt;/p&gt;

&lt;p&gt;$request_filename, 当前请求的文件路径名&lt;/p&gt;

&lt;p&gt;$request_body_file&lt;/p&gt;

&lt;p&gt;$request_uri, 请求的URI，带查询字符串;&lt;/p&gt;

&lt;p&gt;$query_string, 与$args相同;&lt;/p&gt;

&lt;p&gt;$scheme, 所用的协议，比如http或者是https，比如rewrite  ^(.+)$  $scheme://example.com$1  redirect;&lt;/p&gt;

&lt;p&gt;$server_protocol, 请求的协议版本，”HTTP/1.0”或”HTTP/1.1”;&lt;/p&gt;

&lt;p&gt;$server_addr, 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费);&lt;/p&gt;

&lt;p&gt;$server_name, 请求到达的服务器名;&lt;/p&gt;

&lt;p&gt;$server_port, 请求到达的服务器端口号;&lt;/p&gt;

&lt;p&gt;$uri, 请求的URI，可能和最初的值有不同，比如经过重定向之类的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些变量可以用在rewrite规则里，也可以打印日志的时候用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;apache-rewrite-&quot;&gt;Apache Rewrite 规则相关指令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Apache rewrite规则相关指令有&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;RewriteEngine on #打开rewirte功能&lt;/p&gt;

&lt;p&gt;RewriteCond      #相当于nginx if&lt;/p&gt;

&lt;p&gt;RewriteRule      #相当于nginx rewrite命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apache rewrite规则相关&lt;code&gt;标记&lt;/code&gt;有&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;R[=code](force redirect)           #强制外部重定向, 强制在替代字符串加上http://thishost[:thisport]/前缀重定向到外部的URL.如果code不指定，将用缺省的302 HTTP状态码。&lt;/li&gt;
  &lt;li&gt;F(force URL to be forbidden)       #禁用URL,返回403HTTP状态码。&lt;/li&gt;
  &lt;li&gt;G(force URL to be gone)            #强制URL为GONE，返回410HTTP状态码。&lt;/li&gt;
  &lt;li&gt;P(force proxy)                     #强制使用代理转发。&lt;/li&gt;
  &lt;li&gt;L(last rule)                       #表明当前规则是最后一条规则，停止分析以后规则的重写。&lt;/li&gt;
  &lt;li&gt;N(next round)                      #重新从第一条规则开始运行重写过程。&lt;/li&gt;
  &lt;li&gt;C(chained with next rule)          #与下一条规则关联,如果规则匹配则正常处理，该标志无效，如果不匹配，那么下面所有关联的规则都跳过。&lt;/li&gt;
  &lt;li&gt;T=MIME-type(force MIME type)       #强制MIME类型&lt;/li&gt;
  &lt;li&gt;NS (used only if no internal sub-request)  #只用于不是内部子请求&lt;/li&gt;
  &lt;li&gt;NC(no case)                        #不区分大小写&lt;/li&gt;
  &lt;li&gt;QSA(query string append)           #追加请求字符串&lt;/li&gt;
  &lt;li&gt;NE(no URI escaping of output)      #不在输出转义特殊字符,例如：RewriteRule /foo/(.*) /bar?arg=P1\%3d$1 [R,NE] #将能正确的将/foo/zoo转换成/bar?arg=P1=zed&lt;/li&gt;
  &lt;li&gt;S=num(skip next rule(s))           #跳过num条规则&lt;/li&gt;
  &lt;li&gt;E=VAR:VAL(set environment variable)#设置环境变量&lt;/li&gt;
  &lt;li&gt;PT(pass through to next handler)   #传递给下一个处理, 例如：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;    RewriteRule ^/abc(.*) /def$1 [PT] #将会交给/def规则处理
    Alias /def /ghi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;一个简单的Apache rewrite规则语法如下&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RewriteEngine on
RewriteCond %{HTTP_HOST} ^haha.test.com [NC]
RewriteRule ^/(.*) http://hehe.test.com/ [L]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Apache rewrite模块环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第一部分: HTTP headers 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: HTTP_USER_AGENT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.8&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_USER_AGENT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_REFERER&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: http://www.test.cn/test.php&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: _SERVER[“HTTP_REFERER”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_COOKIE&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: ZDEDebuggerPresent=php,phtml,php3&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_COOKIE”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_FORWARDED&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 如果使用代理服务器的话会是代理服务器的IP地址, 本地不容易搭环境测试出值来.&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_FORWARDED”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_HOST&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: www.test.com&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_HOST”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_PROXY_CONNECTION&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 网络连接代理方面的信息. 和HTTP_FORWARDED参数一样. 本地不容易搭环境测试出值来.&lt;/li&gt;
  &lt;li&gt;说明: PHP中貌似未提供这样的服务器信息值. 如果又的话可能等值于: $_SERVER[“HTTP_PROXY_CONNECTION”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_ACCEPT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: text/html,application/xhtml+xml,application/xml;q=0.9,&lt;em&gt;/&lt;/em&gt;;q=0.8&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_ACCEPT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第二部分: server internals 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: DOCUMENT_ROOT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: C:/webRoot/t&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“DOCUMENT_ROOT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_ADMIN&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: youemailaddress@gmail.com&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_ADMIN”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_NAME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: www.test.com&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_NAME”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_ADDR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 127.0.0.1&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_ADDR”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_PORT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 80&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_PORT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_PROTOCOL&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: HTTP/1.1&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_PROTOCOL”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_SOFTWARE&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: Apache/2.2.11 (Win32) PHP/5.2.9-1&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_SOFTWARE”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第三部分: connection &amp;amp; request 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: REMOTE_ADDR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 127.0.0.1 正在浏览当前页面用户的 IP 地址。&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REMOTE_ADDR”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_HOST&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 127.0.0.1 正在浏览当前页面用户的主机名。反向域名解析基于该用户的 REMOTE_ADDR&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REMOTE_HOST”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_PORT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 2574 (变化的值)用户连接到服务器时所使用的端口&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REMOTE_PORT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_USER&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空&lt;/li&gt;
  &lt;li&gt;说明: PHP 好像未提供相关的$_SERVER值.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_IDENT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空&lt;/li&gt;
  &lt;li&gt;说明: PHP 好像未提供相关的$_SERVER值.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REQUEST_METHOD&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: GET&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REQUEST_METHOD”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SCRIPT_FILENAME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: C:/webRoot/t/share77.html&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SCRIPT_FILENAME”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: PATH_INFO&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_REQUEST[“PATH_INFO”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: QUERY_STRING&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: a=b&amp;amp;c=d&amp;amp;e=f&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“QUERY_STRING”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: AUTH_TYPE&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空 当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个是认证的类型&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“AUTH_TYPE”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第四部分: date and time 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: TIME_YEAR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 2009&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的年份值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_MON&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 04&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的月份值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_DAY&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 22&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的日值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_HOUR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 16&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前时间的小时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_MIN&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 26&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前时间的分钟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_SEC&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 34&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前时间的秒&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_WDAY&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 3&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当天是星期几, 从星期日-星期六, 数字从 0-6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 20090422162634&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的时间, 格式为: 年月日时分秒&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第五部分: specials 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: API_VERSION&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 20051115:21&lt;/li&gt;
  &lt;li&gt;说明: apache 的 API 版本信息.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: THE_REQUEST&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: GET /share77.html HTTP/1.1&lt;/li&gt;
  &lt;li&gt;说明: 浏览器发给服务器的请求值. 不包括其他的头信息.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REQUEST_URI&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: /share77.html&lt;/li&gt;
  &lt;li&gt;说明: 浏览器请求的资源信息.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REQUEST_FILENAME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: C:/webRoot/t/share77.html&lt;/li&gt;
  &lt;li&gt;说明: 被请求的资源的在磁盘的物理地址.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: IS_SUBREQ&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: false&lt;/li&gt;
  &lt;li&gt;说明: 如果是 sub-request 则显示为 true, 否则为 false.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTPS&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: off&lt;/li&gt;
  &lt;li&gt;说明: 如果连接使用 SSL/TLS 模式, 则值为on , 否则值为off, 这个参数比较安全, 即使未载入 mod_ssl 模块时.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;apachenginx&quot;&gt;Apache和Nginx实例对比&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Apache Rewrite&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RewriteRule ^/(test1|test2)/$ /yzj/index.php?name=$1 [L]
RewriteRule ^/test/$ /yzj/test.php [L]
RewriteRule ^/(test)&lt;em&gt;([a-zA-Z]+)/$ /yzj/index.php?name=$1&lt;/em&gt;$2 [L] 
RewriteRule ^/test([0-9]*)/$ /yzj/test.php?id=$1 [L]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nginx Rewrite&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;rewrite ^/(test1|test2)/$ /yzj/index.php?name=$1 last;
rewrite ^/test/$ /yzj/test.php last;
rewrite ^/(test)&lt;em&gt;([a-zA-Z]+)/$ /zl/index.php?name=$1&lt;/em&gt;$2 last;
rewrite ^/test([0-9]*)/$ /yzj/test.php?id=$1 last;&lt;/p&gt;

&lt;h2 id=&quot;apachenginx-rewrite&quot;&gt;Apache与Nginx Rewrite规则的一些功能相同或类似的指令、标记对应关系&lt;/h2&gt;

&lt;p&gt;Apache的RewriteCond指令对应Nginx的if指令；&lt;/p&gt;

&lt;p&gt;Apache的RewriteRule指令对应Nginx的rewrite指令；&lt;/p&gt;

&lt;p&gt;Apache的[R]标记对应Nginx的redirect标记；&lt;/p&gt;

&lt;p&gt;Apache的[P]标记对应Nginx的last标记；&lt;/p&gt;

&lt;p&gt;Apache的[R,L]标记对应Nginx的redirect标记；&lt;/p&gt;

&lt;p&gt;Apache的[P,L]标记对应Nginx的last标记；&lt;/p&gt;

&lt;p&gt;Apache的[PT,L]标记对应Nginx的last标记；&lt;/p&gt;
</description>
                <link>http://username.github.io/2016/11/08/apachenginxrewrite</link>
                <guid>http://username.github.io/2016/11/08/apachenginxrewrite</guid>
                <pubDate>Tue, 08 Nov 2016 00:00:00 +0800</pubDate>
        </item>


</channel>
</rss>
