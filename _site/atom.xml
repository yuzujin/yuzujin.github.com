<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tumbler</title>
 <link href="http://username.github.io/atom.xml" rel="self"/>
 <link href="http://username.github.io"/>
 <updated>2016-12-13T14:50:03+08:00</updated>
 <id>http://username.github.io</id>
 <author>
   <name>Zujin</name>
   <email>yuzujin@126.com</email>
 </author>

 
 <entry>
   <title>MySQL索引</title>
   <link href="http://username.github.io/2016/12/13/mysql"/>
   <updated>2016-12-13T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/12/13/mysql</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4个页面，如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;索引的类型&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B-Tree索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设有如下一个表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE People (
	last_name varchar(50)    not null,
	first_name varchar(50)    not null,
	dob        date           not null,
	gender     enum(&#39;m&#39;, &#39;f&#39;) not null,
	key(last_name, first_name, dob)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其索引包含表中每一行的last_name、first_name和dob列。其结构大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/mysql2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，当然，如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。&lt;/li&gt;
  &lt;li&gt;匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。&lt;/li&gt;
  &lt;li&gt;匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。&lt;/li&gt;
  &lt;li&gt;匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。&lt;/li&gt;
  &lt;li&gt;匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。&lt;/li&gt;
  &lt;li&gt;仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Hash索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的，如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。&lt;/p&gt;

&lt;p&gt;假设创建如下一个表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE testhash (
	fname VARCHAR(50) NOT NULL,
	lname VARCHAR(50) NOT NULL,
	KEY USING HASH(fname)
) ENGINE=MEMORY;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设索引使用hash函数f( )，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f(&#39;Arjen&#39;) = 2323

f(&#39;Baron&#39;) = 7437

f(&#39;Peter&#39;) = 8784

f(&#39;Vadim&#39;) = 2458
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，索引的结构大概如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Slot&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2323&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2458&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7437&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8784&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pointer to row 3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Slots是有序的，但是记录不是有序的。当你执行
mysql&amp;gt; SELECT lname FROM testhash WHERE fname=’Peter’;
MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f(‘Peter’) = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。
因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。&lt;/p&gt;

&lt;p&gt;Hash索引有以下一些限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。&lt;/li&gt;
  &lt;li&gt;不能使用hash索引排序。&lt;/li&gt;
  &lt;li&gt;Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。&lt;/li&gt;
  &lt;li&gt;Hash索引只支持等值比较，例如使用=，IN( )和&amp;lt;=&amp;gt;。对于WHERE price&amp;gt;100并不能加速查询。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用索引&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;普通索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–直接创建索引
CREATE INDEX index_name ON table(column(length)	
–修改表结构的方式添加索引
ALTER TABLE table_name ADD INDEX index_name ON (column(length))

–创建表的时候同时创建索引
CREATE TABLE `table` (
	`id` int(11) NOT NULL AUTO_INCREMENT ,
	`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
	`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
	`time` int(10) NULL DEFAULT NULL ,
	PRIMARY KEY (`id`),
	INDEX index_name (title(length))
)

–删除索引
DROP INDEX index_name ON table
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–创建唯一索引
CREATE UNIQUE INDEX indexName ON table(column(length))

–修改表结构
ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))

–创建表的时候直接指定

CREATE TABLE `table` (
	`id` int(11) NOT NULL AUTO_INCREMENT ,
	`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
	`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
	`time` int(10) NULL DEFAULT NULL ,
	PRIMARY KEY (`id`),
	UNIQUE indexName (title(length))
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;全文索引（FULLTEXT）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。&lt;/p&gt;

&lt;p&gt;对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–创建表的适合添加全文索引
CREATE TABLE `table` (
	`id` int(11) NOT NULL AUTO_INCREMENT ,
	`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
	`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
	`time` int(10) NULL DEFAULT NULL ,
	PRIMARY KEY (`id`),
	FULLTEXT (content)
);

–修改表结构添加全文索引
ALTER TABLE article ADD FULLTEXT index_content(content)

–直接创建索引
CREATE FULLTEXT INDEX index_content ON article(content)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;单列索引、多列索引&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组合索引（最左前缀）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;– title,time
– title
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面的几个SQL所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;–使用到上面的索引

SELECT * FROM article WHREE title=&#39;测试&#39; AND time=1234567890;
SELECT * FROM article WHREE utitle=&#39;测试&#39;;

–不使用上面的索引

SELECT * FROM article WHREE time=1234567890;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;设计索引的原则&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;索引的设计可以遵循一些已有的原则，创建索引的时候尽量考虑符合这些原则。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;搜索的索引列，不一定是所要选择的列。最适合索引的列是出现再where子句中的列，或连接子句中指定的列，而不是出现在select关键字后的选择列表中的列。&lt;/li&gt;
  &lt;li&gt;使用唯一索引。考虑考虑某列中值的分布。索引的列的基数越大，索引的效果越好。例如，存放出生日期的列具有不同值，但很容易区分各行。而用来记录性别的列，只含有“M”和“F”，则对此列进行索引没有多大用处，因为不管搜索哪个值，都会得出大约一半的行。&lt;/li&gt;
  &lt;li&gt;使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘IO较少，较短的值比较起来更快。对于较短的键值，索引高速缓存中的块能容纳更多的键值。&lt;/li&gt;
  &lt;li&gt;利用最左前缀。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引，多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。&lt;/li&gt;
  &lt;li&gt;不要过度索引。不要以为索引“越多越好”，每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。如果有一个索引很少利用或从来不用，那么会不必要的减缓表的修改速度。&lt;/li&gt;
  &lt;li&gt;对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以innodb表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询效率。另外，innodb表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>MySQL存储引擎介绍</title>
   <link href="http://username.github.io/2016/12/12/mysql"/>
   <updated>2016-12-12T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/12/12/mysql</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;插件式存储引擎是MySQL数据库最重要的特性之一，用户可以根据应用的需要选择如何存储和索引数据、是否使用事务等。MySQL默认支持多种存储引擎，以适用于不同领域的数据应用需要、用户可以选择不同的存储引擎提高应用的效率、提供灵活的存储，用户甚至可以按照自己的需要定制和使用自己的存储引擎，以实现最大程度的可定制型。&lt;/p&gt;

&lt;p&gt;MySQL 5.0支持的存储引擎包括MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎都是非事务安全表。&lt;/p&gt;

&lt;p&gt;创建新表时如果不指定存储引擎，那么系统就会使用默认存储引擎，MySQL 5.5 之前默认存储引擎室MyISAM，5.5之后改为了InnoDB。如果要修改默认存储引擎，可以在参数文件中设置default-table-type。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 查看当前默认存储引擎：

mysql&amp;gt; show variables like &#39;table_type&#39;;

+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| table_type    | MyISAM |
+---------------+--------+

2. 查看当前数据版本支持（Support）的存储引擎和默认(Default)存储引擎

mysql&amp;gt; show engines \G;

*************************** 1. row ***************************
      Engine: ndbcluster
     Support: NO
     Comment: Clustered, fault-tolerant tables
Transactions: NULL
      	  XA: NULL
  Savepoints: NULL
*************************** 2. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
	  Engine: BLACKHOLE
 	 Support: YES
     Comment: /dev/null storage engine (anything you write to it disappears)
Transactions: NO
  		  XA: NO
  Savepoints: NO
*************************** 4. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: MEMORY
     Support: YES
 	 Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
  	      XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: FEDERATED
     Support: NO
     Comment: Federated MySQL storage engine
Transactions: NULL
          XA: NULL
  Savepoints: NULL
*************************** 7. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
  	  Engine: InnoDB
 	 Support: YES
 	 Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
	      XA: YES
  Savepoints: YES
*************************** 9. row ***************************
      Engine: MyISAM
     Support: DEFAULT
     Comment: Default engine as of MySQL 3.23 with great performance
Transactions: NO
    	  XA: NO
  Savepoints: NO

3. 查看支持的存储引擎

mysql&amp;gt; show variables like &#39;have%&#39;;
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| have_community_features | YES      |
| have_compress           | YES      |
| have_crypt              | YES      |
| have_csv                | YES      |	
| have_dynamic_loading    | YES      |
| have_geometry           | YES      |
| have_innodb             | YES      |
| have_ndbcluster         | DISABLED |
| have_openssl            | NO       |
| have_partitioning       | YES      |
| have_query_cache        | YES      |
| have_rtree_keys         | YES      |
| have_ssl                | NO       |
| have_symlink            | DISABLED |
+-------------------------+----------+

其中value为DISABLED的记录表示支持该存储引擎，但是数据库启动时被禁用。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;常用存储引擎的特点&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MyISAM 不支持事务、也不支持外键，其优点是访问速度快，对事务完整性没有要求或者以select、insert为主的应用基本上都可以使用MyISAM来创建表。&lt;/p&gt;

&lt;p&gt;每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但扩展名分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.frm (存储表定义)&lt;/li&gt;
  &lt;li&gt;.MYD (MYData，存储数据)&lt;/li&gt;
  &lt;li&gt;.MYI (MYIndex，存储索引)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据文件和索引文件可以放置在不同的目录，平均分配IO，获得更快的速度。在创建表的时候可以通过DATA DIRECTORY 和 INDEX DIRECTORY 语句指定索引文件和数据文件的路径，也就是说不同MyISAM 表的索引文件和数据文件可以放置到不同的路径下，文件路径需要是绝对路径，并且具有访问权限。&lt;/p&gt;

&lt;p&gt;MyISAM 类型的表可能会损坏，损坏后的表可能不能被访问，会提示需要修复或者访问后返回错误的结果。MyISAM 类型的表提供修复工具，可以用check table语句来检查MyISAM表的健康，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHECK TABLE tbl_name [, tbl_name] ... [option] ...

option = {
	FOR UPGRADE
  		| QUICK
  		| FAST
  		| MEDIUM
  		| EXTENDED
  		| CHANGED
}

mysql&amp;gt; check table questions;
+--------------------------+-------+----------+----------+
| Table                    | Op    | Msg_type | Msg_text |
+--------------------------+-------+----------+----------+
| feedback.questions 		| check | status   | OK       |
+--------------------------+-------+----------+----------+	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;损坏的MyISAM表可以使用REPAIR TABLE 语句修复，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;REPAIR [NO_WRITE_TO_BINLOG | LOCAL] TABLE
tbl_name [, tbl_name] ...
[QUICK] [EXTENDED] [USE_FRM]

mysql&amp;gt; repair table questions;
+--------------------------+--------+----------+----------+
| Table                    | Op     | Msg_type | Msg_text |
+--------------------------+--------+----------+----------+
| feedback.questions 		| repair | status   | OK       |
+--------------------------+--------+----------+----------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyISAM 表支持3种不同的存储格式，分别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态表 默认 记录固定长度 优点：存储快 缺点：占用空间大&lt;/li&gt;
  &lt;li&gt;动态表 变长字段  优点：占用空间少  缺点：频繁更新和删除记录容易产生碎片&lt;/li&gt;
  &lt;li&gt;压缩表 每个记录被单独压缩，占据非常小的磁盘空间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;InnoDB 具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。&lt;/p&gt;

&lt;p&gt;1、自动增长列&lt;/p&gt;

&lt;p&gt;InnoDB 表的自动增长列可以手工插入，但是插入的值如果是空或者0，则实际插入的将是自动增长后的值。可以通过”ALTER TABLE *** AUTO_INCREMENT=n;” 语句强制设置自动增长列的初始值，默认从1开始，但是该强制的默认值是保留在内存中的，如果该值在使用之前数据库重新启动，那么这个强制的默认值就会丢失，就需要在数据库启动以后重新设置。&lt;/p&gt;

&lt;p&gt;可以使用LAST_INSERT_ID()查询当前线程最后插入记录使用的值。如果一次插入了多条记录，那么返回的是第一条记录使用的自动增长值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select last_insert_id();
+------------------+
| last_insert_id() |
+------------------+
|               40 |
+------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一列，但是对于MyISAM表，自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的。&lt;/p&gt;

&lt;p&gt;2、外键约束&lt;/p&gt;

&lt;p&gt;MySQL 支持外键的存储引擎只有InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。&lt;/p&gt;

&lt;p&gt;在创建索引时，可以指定在删除、更新父表时，对子表进行的相应操作，包括RESTRICT、NO ACTION、CASCADE、SET NULL。其中RESTRICT和NO ACTION相同，是指限制在子表有关联记录的情况下父表不能更新；CASCADE 表示父表在更新或删除时，更新或删除子表对应记录；SET NULL 则表示父表在更新或删除时，子表对应字段被SET NULL。&lt;/p&gt;

&lt;p&gt;当某个表被其他表创建了外键参照，那么该表的对应索引或主键禁止被删除。&lt;/p&gt;

&lt;p&gt;在导入多个表的数据时，如果需要忽略表之前的导入顺序，可以暂时关闭外键的检查；同样，在执行LOAD DATA和ALTER TABLE操作时，可以通过暂时关闭外键约束来加快处理的速度，关闭和打开外键约束的命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SET FOREIGN_KEY_CHECKS = 0;
SET FOREIGN_KEY_CHECKS = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、存储方式&lt;/p&gt;

&lt;p&gt;InnoDB的表空间结构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/mysql1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;InnoDB存储表和索引有以下两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用共享表空间存储，这种方式创建的表的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件。&lt;/li&gt;
  &lt;li&gt;使用多表空间（又称单独表空间）存储，这种方式创建的表的表结构仍然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中。如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”，可以在创建分区时指定每个分区的数据文件位置，以此来将表的IO均匀分布在多个磁盘上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在InnoDB存储引擎中，默认表空间文件是ibdata1，初始化为10M，且可以扩展:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &#39;innodb_data%&#39;;
+-----------------------+------------------------+
| Variable_name         | Value                  |
+-----------------------+------------------------+
| innodb_data_file_path | ibdata1:10M:autoextend |
| innodb_data_home_dir  |                        |
+-----------------------+------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用共享表空间存储方式时，Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。&lt;/p&gt;

&lt;p&gt;而在使用多表空间存储方式时，每个表的数据以一个单独的文件来存放，这个时候的单表限制，又变成文件系统的大小限制了。不同平台下，多表空间文件最大限度：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Operating System  File-size Limit
Win32 w/ FAT/FAT32  2GB/4GB
Win32 w/ NTFS          2TB (possibly larger)
Linux 2.4+          (using ext3 file system) 4TB
Solaris 9/10          16TB
MacOS X w/ HFS+         2TB
NetWare w/NSS file system  8TB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共享表空间与多表空间可以通过在my.cnf中设置参数innodb_file_per_table来转换，若为1，则开启多表空间，否则，开启共享表存储。并且重新启动服务后才可以生效，对于新建的表按照多表空间的方式创建，已有的表仍然使用共享表空间存储。如果将已有的多表空间方式修改回共享表空间方式，则新建表会在共享表空间中创建，但已有的多表空间的表仍然保存原来的访问方式。所以多表空间的参数生效后，只对新建的表生效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &#39;innodb_file%&#39;;
+------------------------+-------+
| Variable_name          | Value |	
+------------------------+-------+	
| innodb_file_io_threads | 4     |
| innodb_file_per_table  | OFF   |
+------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用多表空间特性的表，可以比较方便地进行单表备份和恢复操作，但是直接复制.ibd文件是不行的，因为没有共享表空间的数据字典信息，直接复制的.ibd文件和.frm文件恢复时是不能被正确识别的，但是可以通过下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE tbl_name DISCARD TABLESPACE;
ALTER TABLE tble_name IMPORT TABLESPACE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将备份恢复到数据库中，但是这样的单表备份，只能恢复到表原来所在的数据库中，而不能恢复到其他的数据库中。如果要将单表恢复到目标数据库，则需要通过mysqldump和mysqlimport来实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;即便在多表空间的存储方式下，共享表空间仍然是必须的，Innodb把内部数据词典和在线重做日志放在这个文件中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;MEMORY&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MEMORY 存储引擎将所有数据保存在RAM中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY的缺陷是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据异常终止后表的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用于快速得到访问结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MERGE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用它们。MERGE表的优点在于可以突破对单个MyISAM表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善MERGE表的访问效率。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用存储引擎的对比&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;特点&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MyISAM&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;InnoDB&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MEMORY&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;MERGE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;存储限制&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;有&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;64TB&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;有&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;没有&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;事务安全&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;锁机制&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表锁&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;行锁&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表锁&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;表锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B树索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;哈希索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;全文索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;集群索引&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;数据缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;索引缓存&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;数据可压缩&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;空间使用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;N/A&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;内存使用&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;中等&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;批量插入速度&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;低&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持外键&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>MySql外键介绍</title>
   <link href="http://username.github.io/2016/12/09/mysql"/>
   <updated>2016-12-09T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/12/09/mysql</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;基本概念&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;MySQL中“键”和“索引”的定义相同，所以外键和主键一样也是索引的一种。不同的是MySQL会自动为所有表的主键进行索引，但是外键字段必须由用户进行明确的索引。用于外键关系的字段必须在所有的参照表中进行明确地索引，InnoDB不能自动地创建索引。&lt;/p&gt;

&lt;p&gt;外键可以是一对一的，一个表的记录只能与另一个表的一条记录连接，或者是一对多的，一个表的记录与另一个表的多条记录连接。&lt;/p&gt;

&lt;p&gt;如果需要更好的性能，并且不需要完整性检查，可以选择使用MyISAM表类型，如果想要在MySQL中根据参照完整性来建立表并且希望在此基础上保持良好的性能，最好选择表结构为innoDB类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;参照完整性&lt;/code&gt;：当外键与另一个表的字段有关系，而且这种关系是惟一时，这个系统就称为处于参照完整性的状态。也就是说，如果一个字段在所有的表中只出现一次，而且每个表的这个字段的变化都会影响其他表，这就是存在参照完整性。&lt;/p&gt;

&lt;p&gt;外键的好处：可以使得两张表关联，保证数据的一致性和实现一些级联操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;级联操作&lt;/code&gt;：外键可以保证新插入的记录的完整性。但是，如果在REFERENCES从句中从已命名的表删除记录会怎样？在使用同样的值作为外键的辅助表中会发生什么？很明显，那些记录也应该被删除，否则在数据库中就会有很多无意义的孤立记录。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;外键的使用条件&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;两个表必须是InnoDB表，MyISAM表暂时不支持外键&lt;/li&gt;
  &lt;li&gt;外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显式建立；&lt;/li&gt;
  &lt;li&gt;外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;使用方法&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;外键的定义语法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[CONSTRAINT symbol] FOREIGN KEY [id] (index_col_name, ...)
	REFERENCES tbl_name (index_col_name, ...)
	[ON DELETE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]
	[ON UPDATE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]
	
该语法可以在 CREATE TABLE 和 ALTER TABLE 时使用，如果不指定CONSTRAINT symbol，MYSQL会自动生成一个名字。

ON DELETE、ON UPDATE表示事件触发限制，可设参数：
① RESTRICT（限制外表中的外键改动，默认值）
② CASCADE（跟随外键改动）
③ SET NULL（设空值）
④ SET DEFAULT（设默认值）
⑤ NO ACTION（无动作，默认的）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;创建表1
	create table repo_table(
		repo_id char(13) not null primary key,
		repo_name char(14) not null
	) type=innodb;

创建表2
	create table busi_table(
		busi_id char(13) not null primary key,
		busi_name char(13) not null,
		repo_id char(13) not null,
		foreign key(repo_id) references repo_table(repo_id)
	) type=innodb;

插入数据
	insert into repo_table values(&quot;12&quot;,&quot;sz&quot;); //success
	insert into repo_table values(&quot;13&quot;,&quot;cd&quot;); //success
	insert into busi_table values(&quot;1003&quot;,&quot;cd&quot;, &quot;13&quot;); //success
	insert into busi_table values(&quot;1002&quot;,&quot;sz&quot;, &quot;12&quot;); //success
	insert into busi_table values(&quot;1001&quot;,&quot;gx&quot;, &quot;11&quot;); //failed,
	错误提示：ERROR 1452 (23000): Cannot add or update a child row: 
	a foreign key constraint fails (`smb_man`.`busi_table`, 
	CONSTRAINT `busi_table_ibfk_1` FOREIGN KEY (`repo_id`) REFERENCES `repo_table` (`repo_id`))
	
增加级联操作
	alter table busi_table add constraint id_check foreign key(repo_id)
	references repo_table(repo_id) on delete cascade on update cascade;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;相关操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;外键约束（表2）对父表（表1）的含义:&lt;/p&gt;

&lt;p&gt;在父表上进行update/delete以更新或删除在子表中有一条或多条对应匹配行的候选键时，父表的行为取决于：在定义子表的外键时指定的on update/on delete子句。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;关键字&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CASCADE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;删除包含与已删除键值有参照关系的所有记录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SET NULL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;修改包含与已删除键值有参照关系的所有记录，使用NULL值替换(只能用于已标记为NOT NULL的字段)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;RESTRICT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;拒绝删除要求，直到使用删除键值的辅助表被手工删除，并且没有参照时(这是默认设置，也是最安全的设置)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;NO ACTION&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;啥也不做&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在外键上建立索引:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index repo_id (repo_id),
foreign key(repo_id) references repo_table(repo_id))
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux的Cached Memory</title>
   <link href="http://username.github.io/2016/12/08/linuxcached-memory"/>
   <updated>2016-12-08T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/12/08/linuxcached-memory</id>
   <content type="html">
&lt;h2 id=&quot;cache&quot;&gt;文件Cache&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在 Linux 操作系统中，当应用程序需要读取文件中的数据时，操作系统先分配一些内存，将数据从存储设备读入到这些内存中，然后再将数据分发给应用程序；当需要往文件中写数据时，操作系统先分配内存接收用户数据，然后再将数据从内存写到磁盘上。&lt;/p&gt;

&lt;p&gt;文件 Cache 管理指的就是对这些由操作系统分配，并用来存储文件数据的内存的管理。 Cache 管理的优劣通过两个指标衡量：一是 Cache 命中率，Cache 命中时数据可以直接从内存中获取，不再需要访问低速外设，因而可以显著提高性能；二是有效 Cache 的比率，有效 Cache 是指真正会被访问到的 Cache 项，如果有效 Cache 的比率偏低，则相当部分磁盘带宽会被浪费到读取无用 Cache 上，而且无用 Cache 会间接导致系统内存紧张，最后可能会严重影响性能。&lt;/p&gt;

&lt;p&gt;文件 Cache 是文件数据在内存中的副本，因此文件 Cache 管理与内存管理系统和文件系统都相关：一方面文件 Cache 作为物理内存的一部分，需要参与物理内存的分配回收过程，另一方面文件 Cache 中的数据来源于存储设备上的文件，需要通过文件系统与存储设备进行读写交互。从操作系统的角度考虑，文件 Cache 可以看做是内存管理系统与文件系统之间的联系纽带。因此，文件 Cache 管理是操作系统的一个重要组成部分，它的性能直接影响着文件系统和内存管理系统的性能。&lt;/p&gt;

&lt;p&gt;图 1 描述了 Linux 操作系统中文件 Cache 管理与内存管理以及文件系统的关系示意图。从图中可以看到，在 Linux 中，具体文件系统，如 ext2/ext3、jfs、ntfs 等，负责在文件 Cache和存储设备之间交换数据，位于具体文件系统之上的虚拟文件系统VFS负责在应用程序和文件 Cache 之间通过 read/write 等接口交换数据，而内存管理系统负责文件 Cache 的分配和回收，同时虚拟内存管理系统(VMM)则允许应用程序和文件 Cache 之间通过 memory map的方式交换数据。可见，在 Linux 系统中，文件 Cache 是内存管理系统、文件系统以及应用程序之间的一个联系枢纽。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/cache.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cache-1&quot;&gt;文件Cache数据结构&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在 Linux 的实现中，文件 Cache 分为两个层面，一是 Page Cache，另一个 Buffer Cache，每一个 Page Cache 包含若干 Buffer Cache。内存管理系统和 VFS 只与 Page Cache 交互，内存管理系统负责维护每项 Page Cache 的分配和回收，同时在使用 memory map 方式访问时负责建立映射；VFS 负责 Page Cache 与用户空间的数据交换。而具体文件系统则一般只与 Buffer Cache 交互，它们负责在外围存储设备和 Buffer Cache 之间交换数据。Page Cache、Buffer Cache、文件以及磁盘之间的关系如图 2 所示，Page 结构和 buffer_head 数据结构的关系如图 3 所示。在上述两个图中，假定了 Page 的大小是 4K，磁盘块的大小是 1K。本文所讲述的，主要是指对 Page Cache 的管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/cache1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/cache2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache 项，一个是 radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux 内核利用这个数据结构来通过文件内偏移快速定位 Cache 项，图 4 是 radix tree的一个示意图，该 radix tree 的分叉为4(22)，树高为4，用来快速定位8位文件内偏移。Linux(2.6.7) 内核中的分叉为 64(26)，树高为 6(64位系统)或者 11(32位系统)，用来快速定位 32 位或者 64 位偏移，radix tree 中的每一个叶子节点指向文件内相应偏移所对应的Cache项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/cache3.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另一个数据结构是双向链表，Linux内核为每一片物理内存区域(zone)维护active_list和inactive_list两个双向链表，这两个list主要用来实现物理内存的回收。这两个链表上除了文件Cache之外，还包括其它匿名(Anonymous)内存，如进程堆栈等。&lt;/p&gt;

&lt;h2 id=&quot;cache-2&quot;&gt;文件Cache预读和替换&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Linux内核中文件预读算法的具体过程是这样的：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面(不少于一个页面，通常是三个页面)，这时的预读称为&lt;code&gt;同步预读&lt;/code&gt;。对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的group中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读group扩大一倍，并让底层文件系统读入group中剩下尚不在Cache中的文件数据块，这时的预读称为&lt;code&gt;异步预读&lt;/code&gt;。无论第二次读请求是否命中，系统都要更新当前预读group的大小。&lt;/p&gt;

&lt;p&gt;此外，系统中定义了一个window，它包括前一次预读的group和本次预读的group。任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读window中，这时继续进行异步预读并更新相应的window和group；第二种情况是所请求的页面处于预读window之外，这时系统就要进行同步预读并重置相应的window和group。图5是Linux内核预读机制的一个示意图，其中a是某次读操作之前的情况，b是读操作所请求页面不在window中的情况，而c是读操作所请求页面在window中的情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/cache4.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Linux内核中文件Cache替换的具体过程是这样的：刚刚分配的Cache项链入到inactive_list头部，并将其状态设置为active，当内存不够需要回收Cache时，系统首先从尾部开始反向扫描active_list并将状态不是referenced的项链入到inactive_list的头部，然后系统反向扫描inactive_list，如果所扫描的项的处于合适的状态就回收该项，直到回收了足够数目的Cache项。&lt;/p&gt;

&lt;h2 id=&quot;linux-cache&quot;&gt;Linux Cache查看&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;使用命令 cat /proc/meminfo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MemTotal:       65951816 kB
MemFree:         5619132 kB
Buffers:          973232 kB
Cached:         42700380 kB
SwapCached:            0 kB
Active:         40573736 kB
Inactive:       15884684 kB
Active(anon):   12211624 kB
Inactive(anon):  1134312 kB
Active(file):   28362112 kB
Inactive(file): 14750372 kB
Unevictable:        1892 kB
Mlocked:               0 kB
SwapTotal:             0 kB
SwapFree:              0 kB
Dirty:             37940 kB
Readahead	        0 kB
Writeback:             0 kB
AnonPages:      12786760 kB
Mapped:           317028 kB
Shmem:            559224 kB
Slab:            2973088 kB
SReclaimable:    2860064 kB
SUnreclaim:       113024 kB
KernelStack:       14592 kB
PageTables:       164732 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:    32975908 kB
Committed_AS:   36035680 kB
VmallocTotal:   34359738367 kB
VmallocUsed:      384232 kB
VmallocChunk:   34323892400 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:        6152 kB
DirectMap2M:    67082240 kB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过free -g(-m)命令观察系统的内存使用情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	        total       used       free     shared    buffers     cached
Mem:            62         57          5          0          0         40
-/+ buffers/cache:         15         47
Swap:            0          0          0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第一行用全局角度描述系统使用的内存状况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total——总物理内存 used——已使用内存，一般情况这个值会比较大，total=used+free
used 已经使用的内存数  used=buffers+cached (maybe add shared also) 
free——完全未被使用的内存 shared——应用程序共享内存 
buffers——缓存，主要用于目录方面,inode值等（ls大目录可看到这个值增加） 
cached——缓存，用于已打开的文件 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行描述应用程序的内存使用： &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;前个值表示-buffers/cache——应用程序使用的内存大小，used减去缓存值 
后个值表示+buffers/cache——所有可供应用程序使用的内存大小，free加上缓存值 
  
-buffers/cache=used-buffers-cached 
+buffers/cache=free+buffers+cached 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三行表示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swap的使用：used——已使用 free——未使用
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cache-3&quot;&gt;手动释放Cache（不建议）&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;/proc 是一个虚拟文件系统,我们可以通过对它的读写操作做为与kernel实体间进行通信的一种手段.也就是说可以通过修改/proc中的文件,来对当前 kernel的行为做出调整.那么我们可以通过调整/proc/sys/vm/drop_caches来释放内存.操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先查看/proc/sys/vm/drop_caches的值,默认为0：
# cat /proc/sys/vm/drop_caches
#	0

然后同步一下数据：	
#sync
(执行sync命令(描述:sync命令运行sync子例程。如果必须停止系统，则运行sync命令以确保文件系统的完整性。
sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的i-node、已延迟的块I/O和读写映射文件)


最后修改/proc/sys/vm/drop_caches：

To free  pagecache,  
use  echo 1 &amp;gt; /proc/sys/vm/drop_caches; 
to free dentries and inodes, 
use echo 2 &amp;gt; /proc/sys/vm/drop_caches;
to free pagecache, dentries  and  inodes,  
use echo 3 &amp;gt; /proc/sys/vm/drop_caches.
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Spring Annotation详解</title>
   <link href="http://username.github.io/2016/12/05/spring-annotation"/>
   <updated>2016-12-05T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/12/05/spring-annotation</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;注解（Annotation）提供了一种安全的类似注释的机制，为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻方便的使用这些数据（通过解析注解来使用这些数据），用来将任何的信息或者元数据与程序元素（类、方法、成员变量等）进行关联。其实就是更加直观更加明了的说明，这些说明信息与程序业务逻辑没有关系，并且是供指定的工具或框架使用的。Annotation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的申明语句中。&lt;/p&gt;

&lt;p&gt;Annotation其实是一种接口。通过Java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。Java语言解释器在工作时会忽略这些Annotation，因此在JVM中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annotation类型的信息进行访问和处理。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;注解&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;@RequestMapping&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;类：
@Controller 
@RequestMapping(&quot;/feedback&quot;)
public class FeedbackController {
	@RequestMapping(&quot;/listFeedback&quot;)
	http://localhost/feedback/listFeedback&amp;amp;topicId=1&amp;amp;userId=10&amp;amp;userName=tom
	或者@RequestMapping(params = &quot;method=listFeedback&quot;)
	http://localhost/feedback?method=listFeedback&amp;amp;id=1&amp;amp;userId=10&amp;amp;userName=tom
	public String listFeedback(int id,User user) {}
}

方法：
@RequestMapping(&quot;/feedback/submit&quot;)
@RequestMapping(value=&quot;/feedback/submit&quot;,method = POST)
@RequestMapping(value=&quot;/feedback/submit&quot;,params={&quot;modify=false&quot;}, method=POST)

说明：
@RequestMapping 可以声明到类或方法上

参数绑定说明：
http://localhost/feedback?method=listFeedback&amp;amp;id=1&amp;amp;userId=10&amp;amp;userName=tom
id 参数将绑定到id入参上，而userId和userName URL参数将绑定到user对象的 userId和userName 属性中。
URL 请求中不允许没有 id 参数，否则报错，User的userId属性的类型是基本数据类型，
如果URL中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。
如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。

其他：
@RequestMapping(value = &quot;/test&quot;, consumes=&quot;application/json&quot;) 
仅处理request Content-Type为“application/json”类型的请求。

@RequestMapping(value = &quot;/test/{id}&quot;, produces=&quot;application/json&quot;)
仅处理request请求中Accept头中包含了&quot;application/json&quot;的请求，
同时暗示了返回的内容类型为application/json

支持正则表达式
@RequestMapping(value=&quot;/{textualPart:[a-z-]+}.{numericPart:[\\d]+}&quot;)  
public String regularExpression( @PathVariable String textualPart, 
	@PathVariable String numericPart){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类：（主要讲解常用类型）&lt;/p&gt;

&lt;p&gt;A、处理requet uri 部分（这里指uri template中variable，不含queryString部分）的注解：   @PathVariable;&lt;/p&gt;

&lt;p&gt;B、处理request header部分的注解：   @RequestHeader, @CookieValue;&lt;/p&gt;

&lt;p&gt;C、处理request body部分的注解：@RequestParam,  @RequestBody;&lt;/p&gt;

&lt;p&gt;D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@PathVariable&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.例如
@Controller  
@RequestMapping(&quot;/owners/{ownerId}&quot;)  
public class RelativePathUriTemplateController {  
	@RequestMapping(&quot;/pets/{petId}&quot;)  
	public void findPet(@PathVariable String ownerId, @PathVariable String petId, 
		Model model) {      
		// implementation omitted  
	}  
}
.说明  
当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 
这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@RequestHeader&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
可以把Request请求header部分的值绑定到方法的参数上。

.例如
这是一个Request 的header部分：
Host                    localhost:8080  
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9  
Accept-Language         fr,en-gb;q=0.7,en;q=0.3  
Accept-Encoding         gzip,deflate  
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7  
Keep-Alive  


@RequestMapping(&quot;/displayHeaderInfo.do&quot;)  
public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,  
	@RequestHeader(&quot;Keep-Alive&quot;) long keepAlive)  {}
                          
上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， 
Keep-Alive header的值绑定到参数keepAlive上。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@CookieValue&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
可以把Request header中关于cookie的值绑定到方法的参数上。 

.例如
有如下Cookie值：JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
@RequestMapping(&quot;/displayHeaderInfo.do&quot;)  
public void displayHeaderInfo(@CookieValue(&quot;JSESSIONID&quot;) String cookie)  {}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@RequestParam&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;参数绑定说明
@RequestParam(&quot;id&quot;)
http://localhost/bbtForum.do?method=listBoardTopic&amp;amp;id=1&amp;amp;userId=10&amp;amp;userName=tom
listBoardTopic(@RequestParam(&quot;id&quot;)int topicId,User user)中的topicId绑定到id这个参数， 
那么可以通过对入参使用 @RequestParam 注解来达到目的

@RequestParam(required=false)：参数不是必须的，默认为true
@RequestParam(value=&quot;id&quot;,required=false)

请求处理方法入参的可选类型
• Java 基本数据类型和 String
  默认情况下将按名称匹配的方式绑定到 URL 参数上，可以通过 @RequestParam 注解改变默认的绑定规则

• request/response/session
  既可以是Servlet API的也可以是Portlet API对应的对象，Spring会将它们绑定到Servlet和Portlet容器
  的相应对象上

• org.springframework.web.context.request.WebRequest
  内部包含了 request 对象

• java.util.Locale
  绑定到 request 对应的 Locale 对象上

• java.io.InputStream/java.io.Reader
  可以借此访问 request 的内容

• java.io.OutputStream / java.io.Writer
  可以借此操作 response 的内容

• 任何标注了 @RequestParam 注解的入参
  被标注 @RequestParam 注解的入参将绑定到特定的 request 参数上。

• java.util.Map / org.springframework.ui.ModelMap
  它绑定 Spring MVC 框架中每个请求所创建的潜在的模型对象，它们可以被 Web 视图对象访问（如 JSP ）

• 命令/ 表单对象（注：一般称绑定使用 HTTP GET 发送的 URL 参数的对象为命令对象，
  而称绑定使用HTTP POST 发送的 URL 参数的对象为表单对象）
  它们的属性将以名称匹配的规则绑定到 URL 参数上，同时完成类型的转换。
  而类型转换的规则可以通过 @InitBinder 注解或通过 HandlerAdapter 的配置进行调整

• org.springframework.validation.Errors / org.springframework.validation.BindingResult
  为属性列表中的命令/ 表单对象的校验结果，注意检验结果参数必须紧跟在命令/ 表单对象的后面

• org.springframework.web.bind.support.SessionStatus
  可以通过该类型status对象显式结束表单的处理，这相当于触发session清除其中的通过@SessionAttributes定义的属性
  请求处理方法返回值的可选类型
  
• void
  此时逻辑视图名由请求处理方法对应的 URL 确定，如以下的方法：
  @RequestMapping(&quot;/welcome.do&quot;)
  public void welcomeHandler() {}
  对应的逻辑视图名为 “ welcome ” 

• String
  此时逻辑视图名为返回的字符，如以下的方法：
  @RequestMapping(method = RequestMethod.GET)
  public String setupForm(@RequestParam(&quot;ownerId&quot;) int ownerId, ModelMap model) {
      Owner owner = this.clinic.loadOwner(ownerId);
      model.addAttribute(owner);
      return &quot;ownerForm&quot;;
  }
  对应的逻辑视图名为 “ ownerForm ” 

• org.springframework.ui.ModelMap
  和返回类型为 void 一样，逻辑视图名取决于对应请求的 URL ，如下面的例子：
  @RequestMapping(&quot;/vets.do&quot;)
  public ModelMap vetsHandler() {
      return new ModelMap(this.clinic.getVets());
  }
  对应的逻辑视图名为“vets”，返回的ModelMap将被作为请求对应的模型对象，可以在JSP视图页面中访问到。

• ModelAndView
  当然还可以是传统的 ModelAndView 。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@RequestBody&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
 该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，
 例如application/json, application/xml等；
 
 它是通过使用HandlerAdapter配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。
 
 因为配置有FormHttpMessageConverter，所以也可以用来处理application/x-www-form-urlencoded的内容，
 处理完的结果放在一个MultiValueMap&amp;lt;String, String&amp;gt;里，这种情况在某些特殊需求下使用，
 详情查看FormHttpMessageConverter api;	
 
 .例如
 @RequestMapping(value = &quot;/something&quot;, method = RequestMethod.PUT)  
 public void handle(@RequestBody String body, Writer writer) 
 	throws IOException { 
  		writer.write(body);  
 }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@ModelAttribute&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 作用域：request
• 例如
  @RequestMapping(&quot;/base/userManageCooper/init.do&quot;)
  public String handleInit(@ModelAttribute(&quot;queryBean&quot;) ManagedUser sUser,Model model){
  • 或者
  @ModelAttribute(&quot;coopMap&quot;)// 将coopMap 返回到页面
  public Map&amp;lt;Long,CooperatorInfo&amp;gt; coopMapItems(){}

• 说明
  @ModelAttribute 声明在属性上，表示该属性的value 来源于model里&quot;queryBean&quot; ，并被保存到model里
  @ModelAttribute 声明在方法上，表示该方法的返回值被保存到model里
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@SessionAttributes&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 说明
  Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，
  以便下一个请求属对应的 ModelMap 的属性列表中还能访问到这些属性。
  这一功能是通过类定义处标注 @SessionAttributes 注解来实现的。
  
  @SessionAttributes 只能声明在类上，而不能声明在方法上。 
  • 例如
  @SessionAttributes(&quot;currUser&quot;) // 将ModelMap 中属性名为currUser 的属性
  @SessionAttributes({&quot;attr1&quot;,&quot;attr2&quot;})
  @SessionAttributes(types = User.class)
  @SessionAttributes(types = {User.class,Dept.class})
  @SessionAttributes(types = {User.class,Dept.class},value={&quot;attr1&quot;,&quot;attr2&quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Controller&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如
@Controller
public class SoftCreateController extends SimpleBaseController {}
或者
@Controller(&quot;softCreateController&quot;)

说明
@Controller 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@ResponseBody&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.说明
 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，
 写入到Response对象的body数据区。
 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；

.例如
 @RequestMapping(value = &quot;feedback/submit&quot;, method = { RequestMethod.POST })
 @ResponseBody
 public String submitSuggestion(@RequestBody(required = false) String requestBody) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Service&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如
@Service
public class SoftCreateServiceImpl implements ISoftCreateService {}
或者
@Service(&quot;softCreateServiceImpl&quot;)

说明
@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Autowired&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如
@Autowired
private ISoftPMService softPMService;
或者
@Autowired(required=false)
private ISoftPMService softPMService = new SoftPMServiceImpl();

说明
@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。
与@Resource的区别在于，@Resource允许通过bean名称或bean类型两种方式进行查找
@Autowired(required=false) 表示，如果spring上下文中没有找到该类型的bean时，
才会使用new SoftPMServiceImpl();

@Autowired 标注作用于Map类型时，如果Map的key为String类型，则Spring会将容器中所有类型符合Map的
value对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key。

@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、
ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring
会自动注入这些实现类的实例，不需要额外的操作。

default-autowire属性取值如下：	
byType：按类型装配，可以根据属性的类型，在容器中寻找根该类型匹配的bean.如果发现多个，那么将会抛出异常。如果没有找到，即属性值为null。
byName：按名称装配，可以根据属性的名称，在容器中寻找根该属性名相同的bean,如果没有找到，即属性值为null。
Constructor与byType的方式类似，不同之处在于它应用于构造器参数。如果在容器中没有找到与构造器参数类型一致的bean,那么将会抛出异常。
Autodetect：通过bean类的自省机制来决定是使用constructor还是byType方式进行自动装配。如果发现默认的构造器，那么将使用byType方式。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Cacheable和@CacheFlush&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• @Cacheable ：声明一个方法的返回值应该被缓存
  例如：@Cacheable(modelId = &quot;testCaching&quot;)

• @CacheFlush ：声明一个方法是清空缓存的触发器
  例如：@CacheFlush(modelId = &quot;testCaching&quot;)

• 说明
  要配合缓存处理器使用，参考： http://hanqunfeng.iteye.com/blog/603719
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Resource&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @Resource
  private DataSource dataSource; // inject the bean named &#39;dataSource&#39;

  • 或者
	@Resource(name=&quot;dataSource&quot;)
	@Resource(type=DataSource.class)

• 说明
  @Resource 默认按bean的name 进行查找，如果没有找到会按type 进行查找，
  此时与@Autowired 类似
  在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、
  ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、
  MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。
  此时 name 属性不需要指定 ( 或者指定为&quot;&quot;)，否则注入失败；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@PostConstruct 和@PreDestroy&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• @PostConstruct
  在方法上加上注解@PostConstruct ，这个方法就会在Bean 初始化之后被Spring 容器执行
 （注：Bean 初始化包括，实例化Bean ，并装配Bean 的属性（依赖注入）)。

• @PreDestroy
  在方法上加上注解@PreDestroy ，这个方法就会在Bean 被销毁前被Spring 容器执行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@repository&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 与@Controller 、@Service 类似，都是向spring 上下文中注册bean ，不在赘述。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@component （不推荐使用)&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• @component

  @component 是所有受Spring 管理组件的通用形式，Spring 还提供了更加细化的注解形式：  
  @repository 、@Service 、@Controller ，它们分别对应存储层Bean ，业务层Bean ，和展示层Bean 。
  
  目前版本（2.5 ）中，这些注解与@component 的语义是一样的，完全通用， 在Spring以后的版本中可能
  会给它们追加更多的语义。推荐使用@repository、@Service、@Controller 来替代@component 。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@scope&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @Scope(&quot;session&quot;)
  @Repository()
  public class UserSessionBean implementsSerializable {}

• 说明
  在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，
  同样可以通过@scope 注解来完成

   @Scope中可以指定如下值：
   singleton:定义bean的范围为每个spring容器一个实例（默认值）
   prototype:定义bean可以被多次实例化（使用一次就创建一次）
   request:定义bean的范围是http请求（springMVC中有效）
   session:定义bean的范围是http会话（springMVC中有效）
   global-session:定义bean的范围是全局http会话（portlet中有效）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@InitBinder&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 说明
  如果希望某个属性编辑器仅作用于特定的 Controller ，
  可以在 Controller 中定义一个标注 @InitBinder 注解的方法，
  可以在该方法中向 Controller 了注册若干个属性编辑器

• 例如
  @InitBinder
  public void initBinder(WebDataBinder binder) {
      SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
      dateFormat.setLenient(false);
      binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@Required&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @required              
  public  setName(String name){} 

• 说明
  @ required 负责检查一个bean在初始化时其声明的 set方法是否被执行， 当某个被标注了 @Required 
  的 Setter 方法没有被调用，则 Spring 在解析的时候会抛出异常，以提醒开发者对相应属性进行设置。 
  @Required 注解只能标注在 Setter 方法之上。因为依赖注入的本质是检查 Setter 方法是否被调用了，
  而不是真的去检查属性是否赋值了以及赋了什么样的值。如果将该注解标注在非setXxxx() 类型的方法则被忽略。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@qualifier&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;• 例如
  @Autowired
  @Qualifier(&quot;softService&quot;)
  private ISoftPMService softPMService; 
  
• 说明
  使用@Autowired 时，如果找到多个同一类型的bean，则会抛异常，此时可以使用 @Qualifier(&quot;beanName&quot;)，
  明确指定bean的名称进行注入，此时与 @Resource指定name属性作用相同。
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>SpringMVC框架理解</title>
   <link href="http://username.github.io/2016/12/01/springmvc"/>
   <updated>2016-12-01T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/12/01/springmvc</id>
   <content type="html">
&lt;p&gt;Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。&lt;/p&gt;

&lt;p&gt;Spring的MVC框架主要由前端控制器(DispatcherServlet)、(处理器映射)HandlerMapping、控制器(Handler或Controller)、处理器适配器(HandlerAdapter或Service)、(视图解析器)View Resolver、(视图)View组成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/yuzujin/yuzujin.github.com/blob/master/images/spring3.jpg?raw=true&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行流程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;客户端请求提交到DispatcherServlet&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet将请求提交到Controller&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Controller调用业务逻辑处理后，返回ModelAndView&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视图负责将结果显示到客户端&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;springmvc&quot;&gt;SpringMVC组件&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DispatcherServlet是整个Spring MVC的核心。所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。其主要工作有以下三项：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;截获符合特定格式的URL请求。&lt;/li&gt;
  &lt;li&gt;初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。&lt;/li&gt;
  &lt;li&gt;初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能够完成客户请求到Controller映射。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Controller&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。&lt;/p&gt;

&lt;p&gt;Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。&lt;/p&gt;

&lt;p&gt;从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。&lt;/p&gt;

&lt;h2 id=&quot;springmvc-1&quot;&gt;SpringMVC注解&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;@Controller&lt;/p&gt;

    &lt;p&gt;负责注册一个bean 到spring 上下文中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@Service&lt;/p&gt;

    &lt;p&gt;服务层组件，用于标注业务层组件,表示定义一个bean，自动根据bean的类名实例化一个首写字母为小写的bean&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;@RequestMapping&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　注解为控制器指定可以处理哪些 URL 请求&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@RequestBody&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ResponseBody&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ModelAttribute 　　　&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法&lt;/p&gt;

&lt;p&gt;　在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@RequestParam　&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@PathVariable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　绑定 URL 占位符到入参&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ExceptionHandler&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　注解到方法上，出现异常时会执行该方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@ControllerAdvice&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spring AOP介绍</title>
   <link href="http://username.github.io/2016/12/01/spring-aop"/>
   <updated>2016-12-01T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/12/01/spring-aop</id>
   <content type="html">
&lt;p&gt;AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。&lt;/p&gt;

&lt;p&gt;AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。&lt;/p&gt;

&lt;p&gt;使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。&lt;/p&gt;

&lt;p&gt;下面引用逗逼网友的通俗解释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aop切面编程就是在常规的执行java类中方法前或执行后加入自定义的方法。比如你本来每天都去打酱油，去，
打酱油，回。现在我每天在你打酱油路上等着，你去打酱油的时候我打你一顿，回来的时候给你点糖果吃。
你根本不知道为什么我会在路上拦住打你。所以在切面中插入你自定义的方法，这个方法的执行和本身要执行的
类方法无关系，也就是不是这个类的方法来调用你写的方法的，你写的方法什么时候执行都是要通过在配置指定。
我打完你，你该打酱油还是去打酱油，当然我如果是拦住你让你酱油打少点，你打酱油的时候还是会打那么多，
但是在你打完酱油回来的时候我可以把你的酱油倒些出去，所以嵌入的自定义方法对要调用的类方法本身没有影响，
但是可以操纵这个方法的返结果或者处理结果。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AOP核心概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、横切关注点&lt;/p&gt;

&lt;p&gt;对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点&lt;/p&gt;

&lt;p&gt;2、切面（aspect）&lt;/p&gt;

&lt;p&gt;类是对物体特征的抽象，切面就是对横切关注点的抽象&lt;/p&gt;

&lt;p&gt;3、连接点（joinpoint）&lt;/p&gt;

&lt;p&gt;被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器&lt;/p&gt;

&lt;p&gt;4、切入点（pointcut）&lt;/p&gt;

&lt;p&gt;对连接点进行拦截的定义&lt;/p&gt;

&lt;p&gt;5、通知（advice）&lt;/p&gt;

&lt;p&gt;所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类&lt;/p&gt;

&lt;p&gt;6、目标对象&lt;/p&gt;

&lt;p&gt;代理的目标对象&lt;/p&gt;

&lt;p&gt;7、织入（weave）&lt;/p&gt;

&lt;p&gt;将切面应用到目标对象并导致代理对象创建的过程&lt;/p&gt;

&lt;p&gt;8、引入（introduction）&lt;/p&gt;

&lt;p&gt;在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AOP使用场景&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AOP用来封装横切关注点，具体可以在下面的场景中使用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Authentication 权限&lt;/li&gt;
  &lt;li&gt;Caching 缓存&lt;/li&gt;
  &lt;li&gt;Context passing 内容传递&lt;/li&gt;
  &lt;li&gt;Error handling 错误处理&lt;/li&gt;
  &lt;li&gt;Lazy loading　懒加载&lt;/li&gt;
  &lt;li&gt;Debugging　　调试&lt;/li&gt;
  &lt;li&gt;logging, tracing, profiling and monitoring　记录跟踪　优化　校准&lt;/li&gt;
  &lt;li&gt;Performance optimization　性能优化&lt;/li&gt;
  &lt;li&gt;Persistence　　持久化&lt;/li&gt;
  &lt;li&gt;Resource pooling　资源池&lt;/li&gt;
  &lt;li&gt;Synchronization　同步&lt;/li&gt;
  &lt;li&gt;Transactions 事务&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何使用Spring AOP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以通过配置文件或者编程的方式来使用Spring AOP。&lt;/p&gt;

&lt;p&gt;配置可以通过xml文件来进行，大概有四种方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 基于代理的AOP(配置ProxyFactoryBean，显式地设置advisors, advice, target等)
或AutoProxyCreator(这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象)
2. 纯POJO切面(通过&amp;lt;aop:config&amp;gt;来配置)
3. @AspectJ注解驱动的切面(通过&amp;lt;aop:aspectj-autoproxy&amp;gt;来配置，使用AspectJ的注解来标识通知及切入点)
4. 注入式AspectJ切面
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;基于代理的AOP&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Spring支持五种类型的通知：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Before(前)  org.apringframework.aop.MethodBeforeAdvice&lt;/li&gt;
  &lt;li&gt;After-returning(返回后) org.springframework.aop.AfterReturningAdvice&lt;/li&gt;
  &lt;li&gt;After-throwing(抛出后) org.springframework.aop.ThrowsAdvice&lt;/li&gt;
  &lt;li&gt;Arround(周围) org.aopaliance.intercept.MethodInterceptor&lt;/li&gt;
  &lt;li&gt;Introduction(引入) org.springframework.aop.IntroductionInterceptor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建通知：实现这几个接口，把其中的方法实现了&lt;/li&gt;
  &lt;li&gt;定义切点和通知者：在Spring配制文件中配置这些信息&lt;/li&gt;
  &lt;li&gt;使用ProxyFactoryBean来生成代理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;接口
public interface Eatable {
	void eat(); 
}
	
目标类
public Human implements Eatable {
	public void eat(){
  		System.out.println(&quot;吃饭&quot;);
  	}
}
applicationContext.xml中配置目标类
&amp;lt;bean id=&quot;human&quot; class=&quot;com.test.aop.bean.Human&quot;&amp;gt;
  	
通知类
public class EatHelper implements MethodBeforeAdvice,AfterReturningAdvice {
	public void before(Method mtd, Object[] arg1, Object arg2)
    	throws Throwable {
    		System.out.println(&quot;饭前洗手&quot;);
	}

	public void afterReturning(Object arg0, Method arg1, Object[] arg2,
        Object arg3) throws Throwable {
    		System.out.println(&quot;饭后漱口&quot;);
	}
}
	
applicationContext.xml中配置通知bean
&amp;lt;bean id=&quot;eatHelper&quot; class=&quot;com.test.aop.bean.EatHelper&quot;&amp;gt;&amp;lt;/bean&amp;gt;
	
配置切点
&amp;lt;bean id=&quot;eatPointcut&quot; class=&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot;&amp;gt;
	&amp;lt;property name=&quot;pattern&quot; value=&quot;.*eat&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
	
结合通知和切点
&amp;lt;bean id=&quot;eatHelperAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&amp;gt;
	&amp;lt;property name=&quot;advice&quot; ref=&quot;eatHelper&quot;/&amp;gt;
 	&amp;lt;property name=&quot;pointcut&quot; ref=&quot;eatPointcut&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
 	
调用ProxyFactoryBean产生代理对象
&amp;lt;bean id=&quot;humanProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&amp;gt;
 	&amp;lt;property name=&quot;target&quot; ref=&quot;human&quot;/&amp;gt;
 	&amp;lt;property name=&quot;interceptorNames&quot; value=&quot;eatHelperAdvisor&quot; /&amp;gt;
 	&amp;lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.test.aop.bean.Eatable&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
ProxyFactoryBean是一个代理，我们可以把它转换为proxyInterfaces中指定的实现该interface的代理对象
	
测试
public class Test {
	public static void main(String[] args){
   		ApplicationContext appCtx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
   		Eatable eater = (Eatable)appCtx.getBean(&quot;humanProxy&quot;);
   		eater.eat();
	}
}
	
结果：
	饭前洗手
	吃饭
	饭后漱口
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置切点跟通知的地方,Spring提供了一种自动代理的功能，能让切点跟通知自动进行匹配，修改配置文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;bean id=&quot;eatHelper&quot; class=&quot;com.test.aop.bean.EatHelper&quot;&amp;gt;&amp;lt;/bean&amp;gt;
 &amp;lt;bean id=&quot;human&quot; class=&quot;com.test.aop.bean.Human&quot;&amp;gt;
 &amp;lt;bean id=&quot;eatHelperAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot;&amp;gt;
	&amp;lt;property name=&quot;advice&quot; ref=&quot;eatHelper&quot;/&amp;gt;
 	&amp;lt;property name=&quot;pattern&quot; value=&quot;.*eat&quot;/&amp;gt;
 &amp;lt;/bean&amp;gt;
 &amp;lt;bean id=&quot;human&quot; class=&quot;com.test.aop.bean.Human&quot;&amp;gt;&amp;lt;/bean&amp;gt;
 &amp;lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&amp;gt;

 声明了DefaultAdvisorAutoProxyCreator就能为方法匹配的bean自动创建代理。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;@AspectJ提供的注解&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Aspect   // 标识切面
public class EatHelper {
	public EatHelper(){}

	@Pointcut(&quot;execution(* *.eat())&quot;)  // 指定切点
	public void eatPoint(){}

	@Before(&quot;eatPoint()&quot;)   // 指定运行时通知
	public void beforeEat(){
    	System.out.println(&quot;饭前洗手!&quot;);
	}

	@AfterReturning(&quot;eatPoint()&quot;)  // 指定运行时通知
	public void afterEat(){
    	System.out.println(&quot;饭后漱口!&quot;);
	}
}

// 配置applicationContext.xml
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop
					http://www.springframework.org/schema/aop/spring-aop-2.0.xsd&quot;


然后加上这个标签:
&amp;lt;aop:aspectj-autoproxy/&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;纯粹的POJO切面(最常用的方法)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring在aop的命名空间里面还提供的配置元素:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;aop:aspectj-autoproxy /&gt;
    &lt;aop:advisor&gt; 定义一个AOP通知者
&lt;/aop:advisor&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:after&gt; 后通知
&lt;/aop:after&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:after-returning&gt; 返回后通知
&lt;/aop:after-returning&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:after-throwing&gt; 抛出后通知
&lt;/aop:after-throwing&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:around&gt; 周围通知
&lt;/aop:around&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:aspect&gt;定义一个切面
&lt;/aop:aspect&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:before&gt;前通知
&lt;/aop:before&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:config&gt;顶级配置元素，类似于&lt;beans&gt;这种东西
&lt;/beans&gt;&lt;/aop:config&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;aop:pointcut&gt;定义一个切点

&lt;/aop:pointcut&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码不变，只是修改配置文件,加入AOP配置即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;aop:config&amp;gt;
	&amp;lt;aop:aspect ref=&quot;eatHelper&quot;&amp;gt;
		&amp;lt;aop:before method=&quot;beforeEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
		&amp;lt;aop:after method=&quot;afterEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
	&amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如增加一个打印日志的横切关注点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LogHandler {
	public void LogBefore() {
    	System.out.println(&quot;Log before method&quot;);
	}
	
	public void LogAfter() {
    	System.out.println(&quot;Log after method&quot;);
	}
}

applicationContext.xml配置文件需要修改

&amp;lt;bean id=&quot;logHandler&quot; class=&quot;com.test.aop.LogHandler&quot; /&amp;gt;
    
&amp;lt;aop:config&amp;gt;
	&amp;lt;aop:aspect id=&quot;eat&quot; ref=&quot;eatHelper&quot; order=&quot;1&quot;&amp;gt;
		&amp;lt;aop:before method=&quot;beforeEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
		&amp;lt;aop:after method=&quot;afterEat&quot; pointcut=&quot;execution(* *.eat(..))&quot;/&amp;gt;
	&amp;lt;/aop:aspect&amp;gt;
    &amp;lt;aop:aspect id=&quot;log&quot; ref=&quot;logHandler&quot; order=&quot;2&quot;&amp;gt;
    	&amp;lt;aop:pointcut id=&quot;printLog&quot; expression=&quot;execution(* com.test.aop.Eatable.*(..))&quot; /&amp;gt;
        &amp;lt;aop:before method=&quot;LogBefore&quot; pointcut-ref=&quot;printLog&quot; /&amp;gt;
        &amp;lt;aop:after method=&quot;LogAfter&quot; pointcut-ref=&quot;printLog&quot; /&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要想让logHandler在eatHelper前使用有两个办法：&lt;/p&gt;

&lt;p&gt;（1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序&lt;/p&gt;

&lt;p&gt;（2）把logHandler定义在eatHelper前面，Spring默认以aspect的定义顺序作为织入顺序&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Spring框架IOC/DI</title>
   <link href="http://username.github.io/2016/11/29/spring"/>
   <updated>2016-11-29T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/11/29/spring</id>
   <content type="html">
&lt;p&gt;Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许您选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。&lt;/p&gt;

&lt;p&gt;Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/spring1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。&lt;/p&gt;

&lt;h2 id=&quot;iocdi&quot;&gt;控制反转(IOC/DI)&lt;/h2&gt;

&lt;p&gt;控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器 （在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。原因就是java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object() 这样的语法来完成合作对象的申请工作。这样做的结果就是对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）。&lt;/p&gt;

&lt;p&gt;在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。下表列出了 IOC 的一个实现模式。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;类型 1	服务需要实现专门的接口，通过接口，由对象提供这些服务，可以从对象查询依赖性（例如，需要的附加服务）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型 2	通过 JavaBean 的属性（例如 setter 方法）分配依赖性 (设置注入)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型 3	依赖性以构造函数的形式提供，不以 JavaBean 属性的形式公开 （构造注入）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Spring 框架的 IOC 容器采用类型 2 和类型3 实现。&lt;/p&gt;

&lt;p&gt;引用网友的通俗解释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;首先想说说IoC（Inversion of Control，控制倒转和DI依赖注入是一个概念）。这是spring的核心，贯穿始终。
所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，
举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她
们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂
深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就
必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象
始终会和其他的接口或类藕合起来。

那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了
很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像
林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，
我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过
程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类
都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时
候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，
也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，
现在是所有对象都被spring控制，所以这叫控制反转。如果你还不明白的话，我决定放弃。

IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency 
Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个
Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection
怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针
一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个
Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后
一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的
属性，spring就是通过反射来实现注入的。关于反射的相关资料请查阅java doc。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ioc-&quot;&gt;IOC 容器&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;BeanFactory&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Spring 设计的核心是 org.springframework.beans 包，它的设计目标是与 JavaBean 组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是 BeanFactory 接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/spring2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;spring提供了许多IOC容器的实现。比如XmlBeanFactory，ClasspathXmlApplicationContext等。
其中XmlBeanFactory就是针对最基本的ioc容器的实现，这个IOC容器可以读取XML文件定义的BeanDefinition（XML文件中对bean的描述），ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。从ApplicationContext接口的实现，我们看出其特点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.  支持信息源，可以实现国际化。（实现MessageSource接口） 

2.  访问资源。(实现ResourcePatternResolver接口，这个后面要讲)

3.  支持应用事件。(实现ApplicationEventPublisher接口)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;BeanDefinition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;SpringIOC容器管理了我们定义的各种Bean对象及其相互的关系，Bean对象在Spring实现中是以BeanDefinition来描述的。
Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;示例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;接口Animal

public interface Animal {
    public void say();   
}

接口实现类

public class Cat implements Animal {  
	private String name;  
	public void say() {  
    	System.out.println(&quot;I am &quot; + name + &quot;!&quot;);  
	}  
	public void setName(String name) {  
    	this.name = name;  
	}  
}  

applicationContext.xml bean定义


&amp;lt;bean id=&quot;animal&quot; class=&quot;phz.springframework.test.Cat&quot;&amp;gt;  
    &amp;lt;property name=&quot;name&quot; value=&quot;kitty&quot; /&amp;gt;  
&amp;lt;/bean&amp;gt; 

测试

public static void main(String[] args) {  
    ApplicationContext context = new FileSystemXmlApplicationContext(  
            &quot;applicationContext.xml&quot;);  
    Animal animal = (Animal) context.getBean(&quot;animal&quot;);  
    animal.say();  
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出I am kitty!&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;http://projects.spring.io/spring-framework/&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Tomcat 安全配置</title>
   <link href="http://username.github.io/2016/11/27/apache-tomcat"/>
   <updated>2016-11-27T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/11/27/apache-tomcat-</id>
   <content type="html">
&lt;h2 id=&quot;telnet&quot;&gt;telnet管理端口保护&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改默认的 8005 管理端口为不易猜测的端口（大于 1024）；
修改 SHUTDOWN指令为其他字符串；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(server.xml)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Server port=&quot;8520&quot; shutdown=&quot;dangerous&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ajp&quot;&gt;ajp连接端口保护&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改默认的 ajp 8009 端口为不易冲突的大于1024 端口；
通过 iptables 规则限制ajp 端口访问的权限仅为线上机器(可选)；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(server.xml)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Connector port=&quot;8521&quot; protocol=&quot;AJP/1.3&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;禁用管理端&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;删除默认的{Tomcat安装目录}/conf/tomcat-users.xml 文件，重启 tomcat后将会自动生成新的文件；
删除{Tomcat 安装目录}/webapps 下默认的所有目录和文件；
将 tomcat 应用根目录配置为 tomcat 安装目录以外的目录；
热部署可以关掉，防止被黑客注入木马程序
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;降权启动&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tomcat 启动用户权限必须为非 root 权限，尽量降低 tomcat 启动用户的目录访问权限；
如需直接对外使用 80端口，可通过普通账号启动后，配置 iptables规则进行转发；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;无
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;文件列表访问控制&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.conf/web.xml 文件中default 部分 listings 的配置必须为 false；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;init-param&amp;gt; 
	&amp;lt;param-name&amp;gt;listings&amp;lt;/param-name&amp;gt; 
	&amp;lt;param-value&amp;gt;false&amp;lt;/param-value&amp;gt; 
&amp;lt;/init-param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;web-inf-&quot;&gt;WEB-INF 目录访问控制&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tomcat web 目录里的 WEB-INF 目录默认为禁止访问，但是当tomcat 组合其他webserver 一起使用，并且其他 webserver 和tomcat 指向同一目录时，需要在其他webserver 配置文件里添加禁止访问/WEB-INF 目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Apache：
&amp;lt;Directory &quot;WEB-INF&quot;&amp;gt;
	Order allow,deny
	Deny from all
&amp;lt;/Directory&amp;gt;

Nginx：
location ^~ /WEB-INF
{
 		deny all;
}

Lighttpd:
$HTTP[&quot;url&quot;] =~ &quot;^/WEB-INF/&quot; {
 		url.access-deny = ( &quot;&quot; )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;版本信息隐藏&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改conf/web.xml，重定向 403、404 以及 500等错误到指定的错误页面(全局)；

也可以通过修改应用程序目录下的WEB-INF/web.xml下的配置进行错误页面的重定向（应用级别）；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;error-page&amp;gt;
	&amp;lt;error-code&amp;gt;403&amp;lt;/error-code&amp;gt;
	&amp;lt;location&amp;gt;/forbidden.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&amp;lt;error-page&amp;gt;
	&amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
	&amp;lt;location&amp;gt;/notfound.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&amp;lt;error-page&amp;gt;
	&amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt;
	&amp;lt;location&amp;gt;/systembusy.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;server-header&quot;&gt;Server header重写&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在 HTTP Connector 配置中加入 server 的配置；

当 tomcat HTTP 端口直接提供 web服务时此配置生效，加入此配置，将会替换 http 响应Server header部分的默认配置，默认是Apache-Coyote/1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(conf/server.xml)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
           connectionTimeout=&quot;20000&quot;
           redirectPort=&quot;8443&quot;
           server=&quot;webserver&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;访问限制&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;通过配置，限定访问的 ip 来源
通过配置信任ip 的白名单，拒绝非白名单 ip的访问，此配置主要是针对高保密级别的系统，一般产品线不需要；
Tomcat供了两个参数供你配置：RemoteHostValve 和RemoteAddrValve，前者用于限制主机名，后者用于限制IP地址。
重启生效
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例(conf/server.xml新增一条)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;全局设置（对Tomcat下所有应用生效）
&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
	&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;68.147.18.138,68.135.165.*&quot; deny=&quot;*.*.*.*&quot;/&amp;gt;
	#&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteHostValve&quot; allow=&quot;abc.com&quot; deny=&quot;&quot;/&amp;gt;
&amp;lt;/Host&amp;gt;
 

局部设置 (仅对具体的应用生效)
&amp;lt;Context path=&quot;/test&quot; docBase=&quot;/home/work/tomcat/webapps/test&quot; debug=&quot;0&quot; reloadable=&quot;false&quot; crossContext=&quot;true&quot;&amp;gt;
&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;68.147.18.138,68.135.165.*&quot; deny=&quot;*.*.*.*&quot;/&amp;gt;
&amp;lt;/Context&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;起停脚本权限回收&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;去除其他用户对 Tomcat的 bin 目录下shutdown.sh、startup.sh、catalina.sh 的可执行权限；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chmod -R 744 tomcat/bin/* 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;访问日志格式规范&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;配置内容&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;开启 Tomcat默认访问日志中的Referer 和User-Agent记录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;示例（conf/server.xml）&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;全局设置
&amp;lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&amp;gt;
	&amp;lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t %r %s %b %{Referer}i %{User-Agent}i %D&quot; resolveHosts=&quot;false&quot;/&amp;gt;
&amp;lt;/Host&amp;gt;
局部设置
参考上面的访问限制小节
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Java中日期问题总结</title>
   <link href="http://username.github.io/2016/11/25/java"/>
   <updated>2016-11-25T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/11/25/java</id>
   <content type="html">
&lt;p&gt;由于在写程序的过程中，经常遇到日期的转换，为此通过参考网上的几篇总结，记录下自己需要的问题，以备后用，本文讨论的主要是关于Java API 中 Date, Calendar, TimeZone和DateFormat的使用，和时区的转换问题。&lt;/p&gt;

&lt;h2 id=&quot;date&quot;&gt;Date&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要说明的是 Date 无时区，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;date.toString() 则是按当前 JVM 的默认时区来格式化的，也就是 TimeZone.getDefault() 获得的时区，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同时 date.toString() 是按照 “EEE MMM dd HH:mm:ss zzz yyyy” 来格式化的；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类Date表示特定的瞬间，精确到毫秒。获得一个表示当前时间的Date对象有两种方式：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Date date = new Date();  
Date date = Calendar.getInstance().getTime(); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Date对象本身所存储的毫秒数可以通过date.getTime()方法得到；该函数返回自1970年1月1日 00:00:00 GMT以来此对象表示的毫秒数。&lt;/p&gt;

&lt;p&gt;Calendar的getInstance()方法有参数为TimeZone和Locale的重载，可以使用指定时区和语言环境获得一个日历。无参则使用默认时区和语言环境获得日历。&lt;/p&gt;

&lt;h2 id=&quot;date-to-string&quot;&gt;Date to String&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);  
String strDate = format.format(date);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;string-to-date&quot;&gt;String to Date&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  
Date date = format.parse(strDate);	
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;时区转换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了克服时间上的混乱，1884年在华盛顿召开的一次国际经度会议（又称国际子午线会议[1]）上，规定将全球划分为24个时区（东、西各12个时区）。规定英国（格林尼治天文台旧址）为中时区（零时区）、东1-12区，西1-12区。每个时区横跨经度15度，时间正好是1小时。最后的东、西第12区各跨经度7.5度，以东、西经180度为界。每个时区的中央经线上的时间就是这个时区内统一采用的时间，称为区时，相邻两个时区的时间相差1小时。例如，中国东8区的时间总比泰国东7区的时间早1小时，而比日本东9区的时间迟1小时。因此，出国旅行的人，必须随时调整自己的手表，才能和当地时间相一致。凡向西走，每过一个时区，就要把表拨慢1小时（比如2点拨到1点）；凡向东走，每过一个时区，就要把表拨快1小时（比如1点拨到2点）。并且规定英国（格林尼治天文台旧址）为本初子午线，即零度经线。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GMT 0:00 格林尼治标准时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UTC +00:00 校准的全球时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UTC 是比 GMT 更加精确的世界时间标准，在不需要精确到秒的情况下，通常也将GMT和UTC视作等同；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CST 可以同时表示中国、美国、澳大利亚、古巴四个国家的标准时间；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;GMT时间：即格林威治平时（Greenwich Mean Time）。平太阳时是与视太阳时对应的，由于地球轨道非圆形，运行速度岁地球与太阳距离改变而出现变化，因此视太阳时欠缺均匀性。为了纠正这种不均匀性，天文学家计算地球非圆形轨迹与极轴倾斜对视太阳时的效应。平太阳时就是指经修订之后的视太阳时。在格林威治子午线上的平太阳时称为世界时（UTC），又叫格林威治平时（GMT）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;TimeZone&lt;/strong&gt;表示时区偏移量，本质上以毫秒数保存与GMT的差值。获取TimeZone可以通过时区ID，如”America/New_York”，也可以通过GMT+/-hh:mm来设定。例如北京时间可以表示为GMT+8:00。
TimeZone.getRawOffset()方法可以用来得到当前时区的标准时间到GMT的偏移量。上段提到的”America/New_York”和”GMT+8:00”两个时区的偏移量分别为-18000000和28800000。&lt;/p&gt;

&lt;p&gt;因此，时区转换的&lt;code&gt;原理&lt;/code&gt;就是：在时区间转换时间时，首先用原时间减掉原时间所在时区相对于GMT的偏移量，得到原时间相对与GMT的值，再加上目标时区相对GMT的偏移量即可。然后按照指定日期格式重新转换成Date对象。&lt;/p&gt;

&lt;p&gt;示例代码如下(东京时间转北京时间)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	public class DateTransformer
    {
		public static final String DATE_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
       
    	public static String dateTransformBetweenTimeZone(Date sourceDate, DateFormat formatter, TimeZone sourceTimeZone, TimeZone targetTimeZone) {
    		Long targetTime = sourceDate.getTime() - sourceTimeZone.getRawOffset() + targetTimeZone.getRawOffset();
        	return DateTransformer.getTime(new Date(targetTime), formatter);
    	}
       
    	public static String getTime(Date date, DateFormat formatter){
       		return formatter.format(date);
    	}
       
    	public static void main(String[] args){
    		DateFormat formatter = new SimpleDateFormat(DATE_FORMAT);
    		Date date = Calendar.getInstance().getTime();
    		TimeZone srcTimeZone = TimeZone.getTimeZone(&quot;GMT+8&quot;);
    		TimeZone destTimeZone = TimeZone.getTimeZone(&quot;GMT+9&quot;);
    		System.out.println(DateTransformer.dateTransformBetweenTimeZone(date, formatter, srcTimeZone, destTimeZone));
    	}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;时间跳转&lt;/h2&gt;

&lt;p&gt;获取下一天的日期(示例)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calendar calendar = Calendar.getInstance();  
calendar.set(Calendar.YEAR, 2016);  
calendar.set(Calendar.MONTH, 11);  
calendar.set(Calendar.DAY_OF_MONTH, 25);  
  
SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);  
System.out.println(format.format(calendar.getTime())); // 2016-11-25  
calendar.add(Calendar.DAY_OF_MONTH, 1);                // 增加一天  
System.out.println(format.format(calendar.getTime())); // 2016-11-16 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取下一小时时间(示例)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calendar calendar = Calendar.getInstance();  
calendar.set(Calendar.YEAR, 2016);  
calendar.set(Calendar.MONTH, 11);  
calendar.set(Calendar.DAY_OF_MONTH, 25);  
calendar.set(Calendar.HOUR_OF_DAY, 11);  
  
SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);  
System.out.println(format.format(calendar.getTime())); // 2016-11-25 11:46:38  
calendar.add(Calendar.HOUR_OF_DAY, 1);                 // 增加一个小时  
System.out.println(format.format(calendar.getTime())); // 2016-11-25 12:46:38
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dateformat&quot;&gt;DateFormat&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DateFormat是是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&amp;gt; 文本）、解析（文本-&amp;gt; 日期）和标准化。将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SimpleDateFormat则是一个以与语言环境有关的方式来格式化和解析日期的具体类，可以以“日期和时间模式”字符串指定日期和时间格式。我们函数中所用模式字符串为”yyyy-MM-dd HH:mm:ss”，则输出日期：”2013-07-16 00:00:00”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SimpleDateFormat format1 = new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss zzz yyyy&quot;, Locale.SIMPLIFIED_CHINESE);  
SimpleDateFormat format2 = new SimpleDateFormat(&quot;EEE MMM dd HH:mm:ss zzz yyyy&quot;, Locale.US);  
System.out.println(format1.format(new Date())); // 星期三 七月 17 10:57:50 CST 2013  
System.out.println(format2.format(new Date())); // Wed Jul 17 10:57:50 CST 2013 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他常见的模式字母定义如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;日期或时间元素&lt;/th&gt;
      &lt;th&gt;表示&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;G&lt;/td&gt;
      &lt;td&gt;Era 标志符&lt;/td&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;AD&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;y&lt;/td&gt;
      &lt;td&gt;年&lt;/td&gt;
      &lt;td&gt;Year&lt;/td&gt;
      &lt;td&gt;1996; 96&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;年中的月份&lt;/td&gt;
      &lt;td&gt;Month&lt;/td&gt;
      &lt;td&gt;July; Jul; 07&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;年中的周数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;W&lt;/td&gt;
      &lt;td&gt;月份中的周数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D&lt;/td&gt;
      &lt;td&gt;年中的天数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;189&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;月份中的天数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F&lt;/td&gt;
      &lt;td&gt;月份中的星期&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;星期中的天数&lt;/td&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;Tuesday; Tue&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;Am/pm 标记&lt;/td&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;PM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;H&lt;/td&gt;
      &lt;td&gt;一天中的小时数（0-23）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k&lt;/td&gt;
      &lt;td&gt;一天中的小时数（1-24）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;am/pm 中的小时数（0-11）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;h&lt;/td&gt;
      &lt;td&gt;am/pm 中的小时数（1-12）&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;m&lt;/td&gt;
      &lt;td&gt;小时中的分钟数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;分钟中的秒数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;毫秒数&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;978&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;z&lt;/td&gt;
      &lt;td&gt;时区&lt;/td&gt;
      &lt;td&gt;General time zone	Pacific Standard Time;&lt;/td&gt;
      &lt;td&gt;PST; GMT-08:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;时区&lt;/td&gt;
      &lt;td&gt;RFC 822 time zone&lt;/td&gt;
      &lt;td&gt;-0800&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>mysql主从复制</title>
   <link href="http://username.github.io/2016/11/17/mysql"/>
   <updated>2016-11-17T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/11/17/mysql</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;基本原理&lt;/h2&gt;

&lt;p&gt;mysql支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。mysql复制基于主服务器在二进制日志中跟踪所有对数据库的更改(更新、删除等等)。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收主服务器已经记录到其二进制日志的保存的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，并在本机上执行相同的更新。然后封锁并等待主服务器通知新的更新。从服务器执行备份不会干扰主服务器，在备份过程中主服务器可以继续处理更新。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;本文实验环境如下：&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;操作系统： centos 6.3&lt;/li&gt;
  &lt;li&gt;mysql版本： 5.5&lt;/li&gt;
  &lt;li&gt;master ip: 192.168.1.22&lt;/li&gt;
  &lt;li&gt;slave ip: 192.168.1.23&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mastermycnf&quot;&gt;修改主服务器master(my.cnf):&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    [mysqld]
    log-bin=mysql-bin         //[必须]启用二进制日志
    server-id=1               //[必须]服务器唯一ID，默认是1，一般取IP最后一段
    binlog-do-db=db_nameA     //指定对db_nameA记录二进制日志    
    binlog-ignore-db=db_namB  //指定不对db_namB记录二进制日志
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;slavemycnf&quot;&gt;修改从服务器slave(my.cnf):&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;	[mysqld]
    log-bin=mysql-bin   //[不是必须]启用二进制日志
    server-id=2         //[必须]服务器唯一ID，默认是1，一般取IP最后一段
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mysql&quot;&gt;重启两台服务器的mysql&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;   /etc/init.d/mysql restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;slave&quot;&gt;在主服务器上建立帐户并授权slave:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; GRANT REPLICATION SLAVE ON *.* to &#39;replication&#39;@&#39;%&#39; identified by &#39;test@123&#39;; 
//一般不用root帐号，&#39;%&#39;表示所有客户端都可能连，只要帐号，密码正确，此处可用具体客户端IP代替，如192.168.1.22，加强安全。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mysqlmaster&quot;&gt;登录主服务器的mysql，查询master的状态&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show master status \G;
*************************** 1. row ***************************
  File: mysql-bin.000004
  Position: 257
  Binlog_Do_DB:
  Binlog_Ignore_DB:
  1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;slave-1&quot;&gt;配置从服务器Slave&lt;/h2&gt;

&lt;p&gt;第一种方式：使用change master to命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; change master to master_host=&#39;192.168.1.22&#39;,master_user=&#39;replication&#39;,master_password=&#39;test@123&#39;,master_log_file=&#39;mysql-bin.000004&#39;,master_log_pos=107;
mysql&amp;gt; start slave;    //启动从服务器复制功能
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种方式：修改my.cnf中字段&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# The replication master for this slave - required
#master-host     =   &amp;lt;hostname&amp;gt;
#
# The username the slave will use for authentication when connecting
# to the master - required
#master-user     =   &amp;lt;username&amp;gt;
#
# The password the slave will authenticate with when connecting to
# the master - required
#master-password =   &amp;lt;password&amp;gt;
#
# The port the master is listening on.
# optional - defaults to 3306
#master-port     =  &amp;lt;port&amp;gt;
#master_log_file = &amp;lt;log_file&amp;gt;
#master_log_pos  = &amp;lt;log_pos&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;检查从服务器复制功能状态&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show slave status \G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.1.22
                  Master_User: replication
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000004
          Read_Master_Log_Pos: 257
               Relay_Log_File: 192.168.1.23-bin.000002
                Relay_Log_Pos: 403
        Relay_Master_Log_File: mysql-bin.000004
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 257
              Relay_Log_Space: 569
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
1 row in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;注：Slave_IO及Slave_SQL进程必须正常运行，即YES状态，否则都是错误的状态(如：其中一个NO均属错误)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-3&quot;&gt;主从服务器测试&lt;/h2&gt;

&lt;p&gt;在主服务器Mysql，新建立数据库demo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   mysql&amp;gt; create database demo default character set utf8 collate utf8_general_ci;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在主服务器Mysql查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   mysql&amp;gt; show databases;
   +--------------------+
   | Database           |
   +--------------------+
   | information_schema |
   | demo                |      //新建的
   | mysql                |
   | test                 |
   +--------------------+
   4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从服务器Mysql查询：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   mysql&amp;gt; show databases;
   +--------------------+
   | Database               |
   +--------------------+
   | information_schema |
   | demo                 |       //新建的
   | mysql                 |
   | test          |
   +--------------------+
   4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>mysql binlog入门</title>
   <link href="http://username.github.io/2016/11/08/mysql-binlog"/>
   <updated>2016-11-08T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/11/08/mysql-binlog</id>
   <content type="html">
&lt;h1 id=&quot;binlog&quot;&gt;Binlog&lt;/h1&gt;

&lt;p&gt;二进制日志（BINLOG），记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但是不包括数据查询语句。语句以“事件”的形式保存，它描述了数据的更改过程。此日志对于灾难时的数据恢复起着极其重要的作用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;日志的位置和格式&lt;/h2&gt;

&lt;p&gt;当用–log-bin[=file_name]选项启动时，mysqld开始将数据变更情况写入日志文件。如果没有给出filename值，默认名为主机名后面跟“-bin”。如果给出了文件名，但没有包含路径，则文件默认被写入参数DATADIR（数据目录）指定的目录（重启mysql一次将会自动生成一个新的binlog）。&lt;/p&gt;

&lt;p&gt;开启状态的查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &#39;%log_bin%&#39;;
+---------------------------------+-------+
| Variable_name                   | Value |
+---------------------------------+-------+
| log_bin                         | ON    |
| log_bin_trust_function_creators | OFF   |
| log_bin_trust_routine_creators  | OFF   |
| sql_log_bin                     | ON    |
+---------------------------------+-------+
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MySQL 5.5中，二进制日志的格式分为3种：STATEMENT、ROW、MIXED，可以在启动时通过参数–binlog_format进行设置，这三种日志格式区别如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Statement&lt;/code&gt;：每一条会修改数据的sql都会记录在binlog中。&lt;/p&gt;

&lt;p&gt;优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入，row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)&lt;/p&gt;

&lt;p&gt;缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).&lt;/p&gt;

&lt;p&gt;使用以下函数的语句也无法被复制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LOAD_FILE()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UUID()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;USER()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FOUND_ROWS()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时在INSERT …SELECT 会产生比 RBR 更多的行级锁&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Row&lt;/code&gt;：不记录sql语句上下文相关信息，仅保存哪条记录被修改。&lt;/p&gt;

&lt;p&gt;优点： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题&lt;/p&gt;

&lt;p&gt;缺点:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Mixedlevel&lt;/code&gt;： 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二进制日志的管理&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;开启二进制日志配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;方法一、修改my.cnf参数文件，该方法需要重启&lt;/p&gt;

&lt;p&gt;log-bin = mysql-bin #打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径，如：/home/www/mysql_bin_log/mysql-bin&lt;/p&gt;

&lt;p&gt;关闭二进制日志的方法：log-bin = mysql-bin注释掉即可&lt;/p&gt;

&lt;p&gt;方法二、不重启修改二进制日志配置，该方法mysql的版本需要5.6以上&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SET @@global.log_bin=1&lt;/td&gt;
      &lt;td&gt;0  （1为开启，0为关闭）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;SET @@global.binlog_size=37268(单位bytes)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;暂停二进制日志&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SET sql_log_bin={0&lt;/td&gt;
      &lt;td&gt;1}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;修改二进制日志的大小&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;修改my.cnf参数文件中的max_binlog_size的值；&lt;/p&gt;

&lt;p&gt;说明：如果你的二进制文件的大小超过了max_binlog_size，它就是自动创建新的二进制文件。当然如果恰好在日志文件到达它的最大尺寸时写入了大的事务，那么日志文件还是会超过max_binlog_size的大小&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进行二进制日志的切换&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下当二进制日志写满了或者数据库重启了才会进行切换，但是也可以手工的进行切换的动作&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; flush logs;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其他参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;binlog-cache-size=100m 设置二进制日志缓存大小&lt;/p&gt;

&lt;p&gt;sync-binlog=N（每个N秒将缓存中的二进制日志记录写回硬盘，默认值为0。不过，你经常会陷入group commit函数与I/O之间二选一的矛盾。如果在replication环境中，由于考虑到耐久性与一致性，则需要设置1。同时，还需要设置innodb_flush_log_at_trx_commit=1以及innodb-support-xa=1默认开启；）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二进制日志的读取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;shell&amp;gt; mysqlbinlog log-file
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;二进制日志的删除&lt;/h2&gt;

&lt;p&gt;对于比较繁忙的OLTP（在线事务处理）系统，由于每天生成日志量大，这些日志如果长时间不清除，将对磁盘空间带来很大的浪费。因此，定期删除日志是DBA维护MYSQL数据库的一个重要工作内容。下面将介绍几种删除日志的常见方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行RESET MASTER命令，该命令将删除所有BINLOG日志，新日志编号从“000001”开始，hostname-bin.index是日志的索引文件，记录了最大的日志序号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行PURGE MASTER LOGS TO “mysql-bin.&lt;strong&gt;**&lt;/strong&gt;“命令，该命令将删除“&lt;strong&gt;**&lt;/strong&gt;”编号之前的所有日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法三&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行PURGE MASTER LOGS BEFORE ‘yyyy-mm-dd hh24:mi:ss’命令，该命令将删除日期为“yyyy-mm-dd hh24:mi:ss”之前产生的所有日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法四&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在my.cnf的[mysqld]中设置参数–expire_logs_days=#，此参数的含义是设置日志的过期天数，过了指定的天数后日志将会被自动删除，这样将有利于减少DBA管理日志的工作量。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache和Nginx的rewrite规则浅析</title>
   <link href="http://username.github.io/2016/11/08/apachenginxrewrite"/>
   <updated>2016-11-08T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/11/08/apachenginxrewrite</id>
   <content type="html">
&lt;h2 id=&quot;nginx-rewrite&quot;&gt;Nginx Rewrite规则相关指令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Nginx Rewrite规则相关&lt;code&gt;指令&lt;/code&gt;有&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;if        #条件判断&lt;/p&gt;

&lt;p&gt;rewrite   #跳转&lt;/p&gt;

&lt;p&gt;set       #对变量进行了赋值操作&lt;/p&gt;

&lt;p&gt;return    #该指令将结束执行直接返回http状态码到客户端&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nginx Rewrite规则相关&lt;code&gt;标记&lt;/code&gt;有&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;redirect   #返回302临时重定向 地址栏会显示跳转后的地址&lt;/p&gt;

&lt;p&gt;last       #相当于Apache里的[L]标记，表示完成rewrite（重新将rewrite后的地址在server标签中执行）&lt;/p&gt;

&lt;p&gt;break      #终止匹配, 不再匹配后面的规则（将rewrite后的地址在当前location标签中执行）&lt;/p&gt;

&lt;p&gt;permanent  #返回301永久重定向 地址栏会显示跳转后的地址&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个简单的Nginx Rewrite规则语法如下&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rewrite ^/b/(.*)\.html /play.php?video=$1 break;
如果加上if语句，示例如下： 
if (!-f $request_filename)
{ rewrite ^/img/(.*)$ /site/$host/images/$1 last;      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Nginx rewrite模块环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$args, 请求中的参数;&lt;/p&gt;

&lt;p&gt;$content_length, HTTP请求信息里的”Content-Length”;&lt;/p&gt;

&lt;p&gt;$content_type, 请求信息里的”Content-Type”;&lt;/p&gt;

&lt;p&gt;$document_root, 针对当前请求的根路径设置值;&lt;/p&gt;

&lt;p&gt;$document_uri, 与$uri相同;&lt;/p&gt;

&lt;p&gt;$host, 请求信息中的”Host”，如果请求中没有Host行，则等于设置的服务器名;&lt;/p&gt;

&lt;p&gt;$limit_rate, 对连接速率的限制;&lt;/p&gt;

&lt;p&gt;$request_method, 请求的方法，比如”GET”、”POST”等;&lt;/p&gt;

&lt;p&gt;$remote_addr, 客户端地址;&lt;/p&gt;

&lt;p&gt;$remote_port, 客户端端口号;&lt;/p&gt;

&lt;p&gt;$remote_user, 客户端用户名，认证用;&lt;/p&gt;

&lt;p&gt;$request_filename, 当前请求的文件路径名&lt;/p&gt;

&lt;p&gt;$request_body_file&lt;/p&gt;

&lt;p&gt;$request_uri, 请求的URI，带查询字符串;&lt;/p&gt;

&lt;p&gt;$query_string, 与$args相同;&lt;/p&gt;

&lt;p&gt;$scheme, 所用的协议，比如http或者是https，比如rewrite  ^(.+)$  $scheme://example.com$1  redirect;&lt;/p&gt;

&lt;p&gt;$server_protocol, 请求的协议版本，”HTTP/1.0”或”HTTP/1.1”;&lt;/p&gt;

&lt;p&gt;$server_addr, 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费);&lt;/p&gt;

&lt;p&gt;$server_name, 请求到达的服务器名;&lt;/p&gt;

&lt;p&gt;$server_port, 请求到达的服务器端口号;&lt;/p&gt;

&lt;p&gt;$uri, 请求的URI，可能和最初的值有不同，比如经过重定向之类的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些变量可以用在rewrite规则里，也可以打印日志的时候用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;apache-rewrite-&quot;&gt;Apache Rewrite 规则相关指令&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Apache rewrite规则相关指令有&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;RewriteEngine on #打开rewirte功能&lt;/p&gt;

&lt;p&gt;RewriteCond      #相当于nginx if&lt;/p&gt;

&lt;p&gt;RewriteRule      #相当于nginx rewrite命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apache rewrite规则相关&lt;code&gt;标记&lt;/code&gt;有&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;R[=code](force redirect)           #强制外部重定向, 强制在替代字符串加上http://thishost[:thisport]/前缀重定向到外部的URL.如果code不指定，将用缺省的302 HTTP状态码。&lt;/li&gt;
  &lt;li&gt;F(force URL to be forbidden)       #禁用URL,返回403HTTP状态码。&lt;/li&gt;
  &lt;li&gt;G(force URL to be gone)            #强制URL为GONE，返回410HTTP状态码。&lt;/li&gt;
  &lt;li&gt;P(force proxy)                     #强制使用代理转发。&lt;/li&gt;
  &lt;li&gt;L(last rule)                       #表明当前规则是最后一条规则，停止分析以后规则的重写。&lt;/li&gt;
  &lt;li&gt;N(next round)                      #重新从第一条规则开始运行重写过程。&lt;/li&gt;
  &lt;li&gt;C(chained with next rule)          #与下一条规则关联,如果规则匹配则正常处理，该标志无效，如果不匹配，那么下面所有关联的规则都跳过。&lt;/li&gt;
  &lt;li&gt;T=MIME-type(force MIME type)       #强制MIME类型&lt;/li&gt;
  &lt;li&gt;NS (used only if no internal sub-request)  #只用于不是内部子请求&lt;/li&gt;
  &lt;li&gt;NC(no case)                        #不区分大小写&lt;/li&gt;
  &lt;li&gt;QSA(query string append)           #追加请求字符串&lt;/li&gt;
  &lt;li&gt;NE(no URI escaping of output)      #不在输出转义特殊字符,例如：RewriteRule /foo/(.*) /bar?arg=P1\%3d$1 [R,NE] #将能正确的将/foo/zoo转换成/bar?arg=P1=zed&lt;/li&gt;
  &lt;li&gt;S=num(skip next rule(s))           #跳过num条规则&lt;/li&gt;
  &lt;li&gt;E=VAR:VAL(set environment variable)#设置环境变量&lt;/li&gt;
  &lt;li&gt;PT(pass through to next handler)   #传递给下一个处理, 例如：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;    RewriteRule ^/abc(.*) /def$1 [PT] #将会交给/def规则处理
    Alias /def /ghi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;一个简单的Apache rewrite规则语法如下&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RewriteEngine on
RewriteCond %{HTTP_HOST} ^haha.test.com [NC]
RewriteRule ^/(.*) http://hehe.test.com/ [L]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Apache rewrite模块环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;第一部分: HTTP headers 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: HTTP_USER_AGENT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.8&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_USER_AGENT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_REFERER&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: http://www.test.cn/test.php&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: _SERVER[“HTTP_REFERER”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_COOKIE&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: ZDEDebuggerPresent=php,phtml,php3&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_COOKIE”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_FORWARDED&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 如果使用代理服务器的话会是代理服务器的IP地址, 本地不容易搭环境测试出值来.&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_FORWARDED”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_HOST&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: www.test.com&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_HOST”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_PROXY_CONNECTION&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 网络连接代理方面的信息. 和HTTP_FORWARDED参数一样. 本地不容易搭环境测试出值来.&lt;/li&gt;
  &lt;li&gt;说明: PHP中貌似未提供这样的服务器信息值. 如果又的话可能等值于: $_SERVER[“HTTP_PROXY_CONNECTION”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTP_ACCEPT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: text/html,application/xhtml+xml,application/xml;q=0.9,&lt;em&gt;/&lt;/em&gt;;q=0.8&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“HTTP_ACCEPT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第二部分: server internals 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: DOCUMENT_ROOT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: C:/webRoot/t&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“DOCUMENT_ROOT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_ADMIN&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: youemailaddress@gmail.com&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_ADMIN”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_NAME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: www.test.com&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_NAME”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_ADDR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 127.0.0.1&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_ADDR”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_PORT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 80&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_PORT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_PROTOCOL&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: HTTP/1.1&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_PROTOCOL”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SERVER_SOFTWARE&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: Apache/2.2.11 (Win32) PHP/5.2.9-1&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SERVER_SOFTWARE”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第三部分: connection &amp;amp; request 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: REMOTE_ADDR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 127.0.0.1 正在浏览当前页面用户的 IP 地址。&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REMOTE_ADDR”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_HOST&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 127.0.0.1 正在浏览当前页面用户的主机名。反向域名解析基于该用户的 REMOTE_ADDR&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REMOTE_HOST”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_PORT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 2574 (变化的值)用户连接到服务器时所使用的端口&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REMOTE_PORT”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_USER&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空&lt;/li&gt;
  &lt;li&gt;说明: PHP 好像未提供相关的$_SERVER值.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REMOTE_IDENT&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空&lt;/li&gt;
  &lt;li&gt;说明: PHP 好像未提供相关的$_SERVER值.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REQUEST_METHOD&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: GET&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“REQUEST_METHOD”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: SCRIPT_FILENAME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: C:/webRoot/t/share77.html&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“SCRIPT_FILENAME”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: PATH_INFO&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_REQUEST[“PATH_INFO”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: QUERY_STRING&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: a=b&amp;amp;c=d&amp;amp;e=f&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“QUERY_STRING”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: AUTH_TYPE&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 空 当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个是认证的类型&lt;/li&gt;
  &lt;li&gt;说明: 相当于PHP中的服务器参数: $_SERVER[“AUTH_TYPE”]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第四部分: date and time 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: TIME_YEAR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 2009&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的年份值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_MON&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 04&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的月份值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_DAY&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 22&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的日值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_HOUR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 16&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前时间的小时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_MIN&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 26&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前时间的分钟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_SEC&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 34&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前时间的秒&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME_WDAY&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 3&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当天是星期几, 从星期日-星期六, 数字从 0-6&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: TIME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 20090422162634&lt;/li&gt;
  &lt;li&gt;说明: 服务器获取当前的时间, 格式为: 年月日时分秒&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;第五部分: specials 部分参数&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;参数名称: API_VERSION&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: 20051115:21&lt;/li&gt;
  &lt;li&gt;说明: apache 的 API 版本信息.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: THE_REQUEST&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: GET /share77.html HTTP/1.1&lt;/li&gt;
  &lt;li&gt;说明: 浏览器发给服务器的请求值. 不包括其他的头信息.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REQUEST_URI&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: /share77.html&lt;/li&gt;
  &lt;li&gt;说明: 浏览器请求的资源信息.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: REQUEST_FILENAME&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: C:/webRoot/t/share77.html&lt;/li&gt;
  &lt;li&gt;说明: 被请求的资源的在磁盘的物理地址.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: IS_SUBREQ&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: false&lt;/li&gt;
  &lt;li&gt;说明: 如果是 sub-request 则显示为 true, 否则为 false.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数名称: HTTPS&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样例参考值: off&lt;/li&gt;
  &lt;li&gt;说明: 如果连接使用 SSL/TLS 模式, 则值为on , 否则值为off, 这个参数比较安全, 即使未载入 mod_ssl 模块时.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;apachenginx&quot;&gt;Apache和Nginx实例对比&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Apache Rewrite&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RewriteRule ^/(test1|test2)/$ /yzj/index.php?name=$1 [L]
RewriteRule ^/test/$ /yzj/test.php [L]
RewriteRule ^/(test)&lt;em&gt;([a-zA-Z]+)/$ /yzj/index.php?name=$1&lt;/em&gt;$2 [L] 
RewriteRule ^/test([0-9]*)/$ /yzj/test.php?id=$1 [L]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nginx Rewrite&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;rewrite ^/(test1|test2)/$ /yzj/index.php?name=$1 last;
rewrite ^/test/$ /yzj/test.php last;
rewrite ^/(test)&lt;em&gt;([a-zA-Z]+)/$ /zl/index.php?name=$1&lt;/em&gt;$2 last;
rewrite ^/test([0-9]*)/$ /yzj/test.php?id=$1 last;&lt;/p&gt;

&lt;h2 id=&quot;apachenginx-rewrite&quot;&gt;Apache与Nginx Rewrite规则的一些功能相同或类似的指令、标记对应关系&lt;/h2&gt;

&lt;p&gt;Apache的RewriteCond指令对应Nginx的if指令；&lt;/p&gt;

&lt;p&gt;Apache的RewriteRule指令对应Nginx的rewrite指令；&lt;/p&gt;

&lt;p&gt;Apache的[R]标记对应Nginx的redirect标记；&lt;/p&gt;

&lt;p&gt;Apache的[P]标记对应Nginx的last标记；&lt;/p&gt;

&lt;p&gt;Apache的[R,L]标记对应Nginx的redirect标记；&lt;/p&gt;

&lt;p&gt;Apache的[P,L]标记对应Nginx的last标记；&lt;/p&gt;

&lt;p&gt;Apache的[PT,L]标记对应Nginx的last标记；&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>移动APP http方式登录设计</title>
   <link href="http://username.github.io/2016/11/03/app-http"/>
   <updated>2016-11-03T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/11/03/app-http</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;主体思路&lt;/h2&gt;

&lt;p&gt;由于http方式无法保持长连接，因此登录状态主要依靠token实现。工程流程如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/13.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;思路：APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到APP，以后APP请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App登陆保存数据流程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;App因为要实现自动登陆功能，所以必然要保存一些凭据，所以比较复杂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App登陆要实现的功能&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;密码不会明文存储，并且不能反编绎解密；&lt;/li&gt;
  &lt;li&gt;在服务器端可以控制App端的登陆有效性，防止攻击者拿到数据之后，可以长久地登陆；&lt;/li&gt;
  &lt;li&gt;用户如果密码没有泄露，不用修改密码就可以保证安全性；&lt;/li&gt;
  &lt;li&gt;可以区分不同类型的客户端安全性；比如Android用户受到攻击，只会让Android用户的登陆失效，IOS用户不受影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;密码MD5加盐算法示例（Java）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.security.MessageDigest;  
import java.util.Random;   
import org.apache.commons.codec.binary.Hex;  
public class PasswordUtil {  
    // 生成含有随机盐的密码   
    public static String generate(String password) {  
        Random r = new Random();  
        StringBuilder sb = new StringBuilder(16);  
        sb.append(r.nextInt(99999999)).append(r.nextInt(99999999));  
        int len = sb.length();  
        if (len &amp;lt; 16) {  
            for (int i = 0; i &amp;lt; 16 - len; i++) {  
                sb.append(&quot;0&quot;);  
            }  
        }  
        String salt = sb.toString();  
        password = md5Hex(password + salt);  
        char[] cs = new char[48];  
        for (int i = 0; i &amp;lt; 48; i += 3) {  
            cs[i] = password.charAt(i / 3 * 2);  
            char c = salt.charAt(i / 3);  
            cs[i + 1] = c;  
            cs[i + 2] = password.charAt(i / 3 * 2 + 1);  
        }  
        return new String(cs);  
    }  
    // 校验密码是否正确   
    public static boolean verify(String password, String md5) {  
        char[] cs1 = new char[32];  
        char[] cs2 = new char[16];  
        for (int i = 0; i &amp;lt; 48; i += 3) {  
            cs1[i / 3 * 2] = md5.charAt(i);  
            cs1[i / 3 * 2 + 1] = md5.charAt(i + 2);  
            cs2[i / 3] = md5.charAt(i + 1);  
        }  
        String salt = new String(cs2);  
        return md5Hex(password + salt).equals(new String(cs1));  
    }  
    // 获取十六进制字符串形式的MD5摘要  
    public static String md5Hex(String src) {  
        try {  
            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);  
            byte[] bs = md5.digest(src.getBytes());  
            return new String(new Hex().encode(bs));  
        } catch (Exception e) {  
            return null;  
        }  
    }  
    public static void main(String[] args) {  
        String password = generate(&quot;admin&quot;);  
        System.out.println(verify(&quot;admin&quot;, password));  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;App第一次登陆流程&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户输入密码，App把这些信息用RSA公钥加密：(用户名,密码,时间,mac,随机数)，并发送到服务器。&lt;/li&gt;
  &lt;li&gt;服务器用RSA私钥解密，判断时间（可以动态调整1天到7天），如果不在时间范围之内，则登陆失败。如果在时间范围之内，再调用coreservice判断用户名和密码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里判断时间，主要是防止攻击者截取到加密串后，可以长久地利用这个加密串来登陆。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果服务器判断用户成功登陆，则第一步，用AES加密：(随机salt,用户名,客户端类型,时间)，以MD5(随机salt,用户名,客户端类型,时间)为key，存到缓存，第二步，以（用户名+guid）为key，第一步生成MD5为value，存到缓存里&lt;/li&gt;
  &lt;li&gt;客户端保存服务器返回的加密串MD5值（作为token）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;App自动登陆的流程&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;App发送保存的加密串到服务器，（加密串（token），用户名，mac，随机数）==&amp;gt;RSA公钥加密&lt;/li&gt;
  &lt;li&gt;服务器用RSA私钥解密，再用加密串（token），到缓存里查询。如果能查到该token，则用户登陆成功。否则登陆失败。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;同一个账号多设备登录实现&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过设备guid区分唯一设备&lt;/li&gt;
  &lt;li&gt;以用户名+guid为key，存储token，这样就可以保存不同设备的登录信息。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>在Eclipse上搭建Spirng+SpringMVC+Maven+Mybatis+MySQL项目</title>
   <link href="http://username.github.io/2016/10/12/eclipsespirngspringmvcmavenmybatismysql"/>
   <updated>2016-10-12T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/10/12/eclipsespirngspringmvcmavenmybatismysql</id>
   <content type="html">
&lt;p&gt;本文中所使用到的各个软件版本如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Software&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Version&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Spring&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.2.9.RELEASE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Maven&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.3.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Mybatis&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3.2.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MySQL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5.1.49&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Java&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1.8.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Eclipse&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Mars.2 Release (4.5.2)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Tomcat&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8.0.33&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面详细讲述使用eclipse进行Spring+SpringMVC+Maven+Mybatis+MySQL项目搭建过程，包括搭建步骤和配置步骤。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;创建数据库和表&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `t_user` (
  `USER_ID` int(11) NOT NULL AUTO_INCREMENT,
  `USER_NAME` char(30) NOT NULL,
  `USER_PASSWORD` char(10) NOT NULL,
  PRIMARY KEY (`USER_ID`),
  KEY `IDX_NAME` (`USER_NAME`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8

INSERT INTO t_user (USER_ID, USER_NAME, USER_PASSWORD) VALUES (1, &#39;test1&#39;, &#39;123456&#39;);
INSERT INTO t_user (USER_ID, USER_NAME, USER_PASSWORD) VALUES (2, &#39;test2&#39;, &#39;123456&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;maven&quot;&gt;创建Maven工程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;选择工程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;选择工作空间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不要勾选快速框架，下一步，选择webapp框架：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;填写输出包名、group id、artifact id&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建好的目录结构如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;右键工程properties，左侧java build path，选择source标签，会发现src/main/java和src/test/java目录缺失：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/10.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击add folder,添加缺失的目录：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/11.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成后目录结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/12.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;添加包依赖，编辑pom.xml文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; 
   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.test.global.mobile.tools&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;test&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
  
  &amp;lt;properties&amp;gt;
      &amp;lt;druid-version&amp;gt;1.0.14&amp;lt;/druid-version&amp;gt;
      &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
      &amp;lt;jdk.version&amp;gt;1.8&amp;lt;/jdk.version&amp;gt;
      &amp;lt;!-- spring版本号 --&amp;gt;
      &amp;lt;spring.version&amp;gt;3.2.9.RELEASE&amp;lt;/spring.version&amp;gt;
      &amp;lt;!-- log4j日志文件管理包版本 --&amp;gt;
      &amp;lt;slf4j.version&amp;gt;1.6.6&amp;lt;/slf4j.version&amp;gt;
      &amp;lt;log4j.version&amp;gt;1.2.17&amp;lt;/log4j.version&amp;gt;
      &amp;lt;!-- junit版本号 --&amp;gt;
      &amp;lt;junit.version&amp;gt;4.8.2&amp;lt;/junit.version&amp;gt;
      &amp;lt;!-- mybatis版本号 --&amp;gt;
      &amp;lt;mybatis.version&amp;gt;3.2.1&amp;lt;/mybatis.version&amp;gt;
   &amp;lt;/properties&amp;gt;
      
   &amp;lt;dependencies&amp;gt;
      &amp;lt;!-- spring --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;!-- common --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;commons-httpclient&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;commons-httpclient&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!--mybatis依赖 --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${mybatis.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!-- mybatis/spring包 --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.2.0&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!-- log4j --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;commons-lang&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;commons-lang&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;!-- slf4j --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${slf4j.version}&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;!-- gson --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.2.4&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;!-- json --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;net.sf.json-lib&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;json-lib&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
          &amp;lt;classifier&amp;gt;jdk15&amp;lt;/classifier&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.codehaus.jackson&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;jackson-mapper-asl&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.9.10&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;!-- cache --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;com.test.global.mobile.server&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;dataaccess-cache&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;!-- test --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${junit.version}&amp;lt;/version&amp;gt;
          &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
          &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!-- Database --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;5.1.29&amp;lt;/version&amp;gt;
      &amp;lt;/dependency&amp;gt;

      &amp;lt;!-- Provided --&amp;gt;
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;javax&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;javaee-api&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;6.0&amp;lt;/version&amp;gt;
          &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
      &amp;lt;/dependency&amp;gt;
      
      &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;javax&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;javaee-web-api&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;6.0&amp;lt;/version&amp;gt;
          &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
      &amp;lt;/dependency&amp;gt;
   
  &amp;lt;/dependencies&amp;gt; 
  &amp;lt;build&amp;gt;
      &amp;lt;finalName&amp;gt;pocketbonus&amp;lt;/finalName&amp;gt;
      &amp;lt;plugins&amp;gt;
          &amp;lt;plugin&amp;gt;
              &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;version&amp;gt;2.3.2&amp;lt;/version&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
                  &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
              &amp;lt;/configuration&amp;gt;
 
                   &amp;lt;/plugin&amp;gt;
          &amp;lt;plugin&amp;gt;
              &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
              &amp;lt;configuration&amp;gt;
                  &amp;lt;version&amp;gt;3.0&amp;lt;/version&amp;gt;
              &amp;lt;/configuration&amp;gt;
          &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
  
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;配置文件&lt;/h2&gt;

&lt;h3 id=&quot;mybatis&quot;&gt;mybatis配置&lt;/h3&gt;

&lt;p&gt;在src/main/resources下创建mybatis目录，在目录下创建mybatis-config.xml文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; 
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;数据源配置&lt;/h3&gt;

&lt;p&gt;在src/main/resources下创建properties目录，在目录下创建test_jdbc.properties文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jdbc_driverClassName=com.mysql.jdbc.Driver
jdbc_url=jdbc:mysql://localhost:3306/testdb?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;zeroDateTimeBehavior=round
jdbc_username=root
jdbc_password=123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中jdbc_url中的useUnicode=true&amp;amp;characterEncoding=utf8指定编码格式，zeroDateTimeBehavior=round会将0000-00-00 00:00:00转换为最近的日期0001-01-01，否则会报错Cannot convert value ‘0000-00-00 00:00:00’ from column 1 to TIMESTAMP。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;表映射文件配置&lt;/h3&gt;

&lt;p&gt;在src/main/resources下创建mapper目录，在目录下创建userMapper.xml文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
    &amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; 
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
    &amp;lt;mapper namespace=&quot;com.test.dao.UserDao&quot;&amp;gt;
        &amp;lt;!--设置domain类和数据库中表的字段一一对应，注意数据库字段和domain类中的字段名称不致，此处一定要！--&amp;gt;
        &amp;lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.test.domain.User&quot;&amp;gt;
            &amp;lt;id column=&quot;USER_ID&quot; property=&quot;userId&quot; jdbcType=&quot;INTEGER&quot; /&amp;gt;
            &amp;lt;result column=&quot;USER_NAME&quot; property=&quot;userName&quot; jdbcType=&quot;CHAR&quot; /&amp;gt;
            &amp;lt;result column=&quot;USER_PASSWORD&quot; property=&quot;userPassword&quot; jdbcType=&quot;CHAR&quot; /&amp;gt;
        &amp;lt;/resultMap&amp;gt;
        &amp;lt;!-- 查询单条记录 --&amp;gt;
        &amp;lt;select id=&quot;selectUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;BaseResultMap&quot;&amp;gt;
            SELECT * FROM t_user WHERE USER_ID = #{userId}
        &amp;lt;/select&amp;gt;
    &amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;spring-application&quot;&gt;Spring application文件配置&lt;/h3&gt;

&lt;p&gt;在src/main/resources下创建applicationContext.xml文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
           http://www.springframework.org/schema/aop  
           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
           http://www.springframework.org/schema/context  
           http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&amp;gt;

     &amp;lt;!-- 引入jdbc配置文件 --&amp;gt;  
     &amp;lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&amp;gt;
        &amp;lt;property name=&quot;locations&quot;&amp;gt;
            &amp;lt;list&amp;gt;
               &amp;lt;value&amp;gt;classpath:properties/*.properties&amp;lt;/value&amp;gt;
                &amp;lt;!--要是有多个配置文件，只需在这里继续添加即可 --&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;

     &amp;lt;!-- 配置数据源 --&amp;gt;
     &amp;lt;bean id=&quot;dataSource&quot;
        class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
        &amp;lt;!-- 不使用properties来配置 --&amp;gt;
        &amp;lt;!-- &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&amp;gt; 
             &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/learning&quot; /&amp;gt; 
             &amp;lt;property name=&quot;username&quot; value=&quot;root&quot; /&amp;gt; 
             &amp;lt;property name=&quot;password&quot; value=&quot;christmas258@&quot; /&amp;gt; --&amp;gt;
        &amp;lt;!-- 使用properties来配置 --&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot;&amp;gt;
            &amp;lt;value&amp;gt;${jdbc_driverClassName}&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;url&quot;&amp;gt;
            &amp;lt;value&amp;gt;${jdbc_url}&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;username&quot;&amp;gt;
            &amp;lt;value&amp;gt;${jdbc_username}&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;password&quot;&amp;gt;
            &amp;lt;value&amp;gt;${jdbc_password}&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;

     &amp;lt;!-- 自动扫描了所有的XxxxMapper.xml对应的mapper接口文件，这样就不用一个一个手动配置Mpper的映射了，只要Mapper接口类和Mapper映射文件对应起来就可以了。 --&amp;gt;
     &amp;lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&amp;gt;
        &amp;lt;property name=&quot;basePackage&quot;
            value=&quot;com.luo.dao&quot; /&amp;gt;
     &amp;lt;/bean&amp;gt;

     &amp;lt;!-- 配置Mybatis的文件 ，mapperLocations配置**Mapper.xml文件位置，configLocation配置mybatis-config文件位置--&amp;gt;
     &amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
        &amp;lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&amp;gt;  
        &amp;lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/mybatis-config.xml&quot; /&amp;gt;
        &amp;lt;!-- &amp;lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.tiantian.ckeditor.model&quot; /&amp;gt; --&amp;gt;
     &amp;lt;/bean&amp;gt;

     &amp;lt;!-- 自动扫描注解的bean --&amp;gt;
     &amp;lt;context:component-scan base-package=&quot;com.test.service&quot; /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;接口和类的配置&lt;/h2&gt;

&lt;h3 id=&quot;pojo&quot;&gt;添加POJO类&lt;/h3&gt;

&lt;p&gt;在src/main/java下创建package为com.test.global.mobile.tools.pb.model，在package下创建User.java类文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.test.global.mobile.tools.pb.model;

public class User {

    private Integer userId;  
    private String userName;  
    private String userPassword;  


    public Integer getUserId() {  
        return userId;  
    }  

    public void setUserId(Integer userId) {  
        this.userId = userId;  
    }  

    public String getUserName() {  
        return userName;  
    }  

    public void setUserName(String userName) {  
        this.userName = userName;  
    }  

    public String getUserPassword() {  
        return userPassword;  
    }  

    public void setUserPassword(String userPassword) {  
        this.userPassword = userPassword;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;dao&quot;&gt;添加DAO层类文件&lt;/h3&gt;

&lt;p&gt;在src/main/java下创建package为com.test.global.mobile.tools.pb.dao，在package下创建UserDao.java类文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.test.global.mobile.tools.pb.dao;

import com.test.global.mobile.tools.pb.model.User;

public interface UserDao {

    /**
     * @param userId
     * @return User
     */
    public User selectUserById(Integer userId);  

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;添加实现类和接口&lt;/h3&gt;

&lt;p&gt;在src/main/java下创建package为com.test.global.mobile.tools.pb.service，在package下创建UserService.java接口类和UserServiceImpl实现类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.test.global.mobile.tools.pb.service;

import com.test.global.mobile.tools.pb.model.User;

public interface UserService {
    User selectUserById(Integer userId);  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package com.test.global.mobile.tools.pb.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.test.global.mobile.tools.pb.dao.UserDao;
import com.test.global.mobile.tools.pb.model.User;

@Service  
public class UserServiceImpl implements UserService {

    @Autowired  
    private UserDao userDao;  

    public User selectUserById(Integer userId) {  
        return userDao.selectUserById(userId);  

    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;单元测试&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;添加测试用例类&lt;/h3&gt;

&lt;p&gt;在src/test/java下创建包com.test.baseTest，包下面创建测试用例类SpringTestCase.java：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.test.baseTest;

import org.junit.runner.RunWith;  
import org.springframework.test.context.ContextConfiguration;  
import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;  
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;  

//指定bean注入的配置文件  
@ContextConfiguration(locations = { &quot;classpath:applicationContext.xml&quot; })  
//使用标准的JUnit @RunWith注释来告诉JUnit使用Spring TestRunner  
@RunWith(SpringJUnit4ClassRunner.class)  
public class SpringTestCase extends AbstractJUnit4SpringContextTests {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在src/test/java下创建包com.test.service，包下面创建测试服务类UserServiceTest.java：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.test.service;

import org.junit.Test;  
import org.springframework.beans.factory.annotation.Autowired;  
import com.test.baseTest.SpringTestCase;  
import com.test.global.mobile.tools.pd.model.User;

public class UserServiceTest extends SpringTestCase {

    @Autowired  
    private UserService userService; 

    @Test  
    public void selectUserByIdTest(){  
        User user = userService.selectUserById(1);  
        System.out.println(user.getUserName() + &quot;:&quot; + user.getUserPassword());
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行单元测试，UserServiceTest右键Run As –&amp;gt;Junit Test，在控制台可以看到运行结果。&lt;/p&gt;

&lt;h2 id=&quot;springmvc&quot;&gt;配置Springmvc&lt;/h2&gt;

&lt;p&gt;在src/main/resource中添加springmvc文件夹，然后添加文件spring-mvc.xml，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
  xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
  xsi:schemaLocation=&quot;
    http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context-3.2.xsd
    http://www.springframework.org/schema/mvc
    http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;&amp;gt;

   &amp;lt;mvc:annotation-driven /&amp;gt; 
   &amp;lt;!-- 扫描controller（controller层注入） --&amp;gt;
   &amp;lt;context:component-scan base-package=&quot;com.test.global.mobile.tools.pd.controller&quot;/&amp;gt;  

   &amp;lt;!-- 对模型视图添加前后缀 --&amp;gt;
   &amp;lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
      p:prefix=&quot;/WEB-INF/view/&quot; p:suffix=&quot;.jsp&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;webxml&quot;&gt;配置web.xml&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;
    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&amp;gt;
    &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;
   &amp;lt;!-- 起始欢迎界面 --&amp;gt;
    &amp;lt;welcome-file-list&amp;gt;
        &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
    &amp;lt;/welcome-file-list&amp;gt;

    &amp;lt;!-- 读取spring配置文件 --&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:application.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    &amp;lt;!-- 设计路径变量值 --&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;webAppRootKey&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;springmvc.root&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;


    &amp;lt;!-- Spring字符集过滤器 --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;SpringEncodingFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;SpringEncodingFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;

    &amp;lt;listener&amp;gt;
        &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;

    &amp;lt;!-- springMVC核心配置 --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;!--spingMVC的配置路径  --&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:springmvc/spring-mvc.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;!-- 拦截设置 --&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

    &amp;lt;!-- 错误跳转页面 --&amp;gt;
    &amp;lt;error-page&amp;gt;
        &amp;lt;!-- 路径不正确 --&amp;gt;
        &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
        &amp;lt;location&amp;gt;/WEB-INF/errorpage/404.jsp&amp;lt;/location&amp;gt;
    &amp;lt;/error-page&amp;gt;
    &amp;lt;error-page&amp;gt;
        &amp;lt;!-- 没有访问权限，访问被禁止 --&amp;gt;
        &amp;lt;error-code&amp;gt;405&amp;lt;/error-code&amp;gt;
        &amp;lt;location&amp;gt;/WEB-INF/errorpage/405.jsp&amp;lt;/location&amp;gt;
    &amp;lt;/error-page&amp;gt;
    &amp;lt;error-page&amp;gt;
        &amp;lt;!-- 内部错误 --&amp;gt;
        &amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt;
        &amp;lt;location&amp;gt;/WEB-INF/errorpage/500.jsp&amp;lt;/location&amp;gt;
    &amp;lt;/error-page&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;添加控制类&lt;/h2&gt;

&lt;p&gt;在src/main/java下新建一个包com.test.global.mobile.tools.pd.controller.然后新建一个类UserController.java,其内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.test.controller;

import javax.annotation.Resource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;
import com.test.global.mobile.tools.pd.model.User;
import com.test.global.mobile.tools.pd.service.UserService;

@Controller  
public class UserController {  

    @Resource  
    private UserService userService;  

    @RequestMapping(&quot;/&quot;)    
    public ModelAndView getIndex(){      
        ModelAndView mav = new ModelAndView(&quot;index&quot;);   
        User user = userService.selectUserById(1);  
        mav.addObject(&quot;user&quot;, user);   
        return mav;    
    }    
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成。&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;遇到的问题&lt;/h2&gt;

&lt;p&gt;解决Cannot change version of project facet Dynamic web module to 2.5：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;找到 .setting文件夹内的org.eclipse.wst.common.project.facet.core.xml文件，文件格式大致如下：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;faceted-project&gt;
&lt;runtime name=&quot;Apache Tomcat v5.5&quot; /&gt;
&lt;fixed facet=&quot;jst.web&quot; /&gt;
&lt;fixed facet=&quot;jst.java&quot; /&gt;
&lt;installed facet=&quot;jst.java&quot; version=&quot;5.0&quot; /&gt;
&lt;installed facet=&quot;jst.web&quot; version=&quot;2.5&quot; /&gt;
&lt;installed facet=&quot;wst.jsdt.web&quot; version=&quot;1.0&quot; /&gt;
&lt;/faceted-project&gt;
&lt;p&gt;直接手动修改jst.web对应的version即可。最后重启tomcatX就可以正常使用了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;修改web.xml&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;  
&amp;lt;web-app version=&quot;2.5&quot;  
    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee  
    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&amp;gt;  
      
  &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;  
&amp;lt;/web-app&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在pom.xml添加依赖&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt;
&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>配置eclipse&amp;maven&amp;tomcat基础开发环境</title>
   <link href="http://username.github.io/2016/10/12/eclipsemaventomcat"/>
   <updated>2016-10-12T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/10/12/eclipsemaventomcat</id>
   <content type="html">
&lt;h3 id=&quot;eclipse&quot;&gt;安装eclipse&lt;/h3&gt;

&lt;p&gt;本次实验下载的是eclipse MARS release，版本，该版本已经集成里maven插件。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;安装Java&lt;/h3&gt;

&lt;p&gt;根据系统版本（本文系统基于ios）选择合适的jdk版本下载安装，安装过程中会出现两次安装提示，第一次是安装jdk，第二次是安装jre。&lt;/p&gt;

&lt;p&gt;安装完成后, 在.bash_profile中设置jdk环境变量：JAVA_HOME，修改Path变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;JAVA_HOME=&quot;`/usr/libexec/java_home`&quot;
PATH=$JAVA_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改完成后，不要忘记运行source .bash_profile，使其生效&lt;/p&gt;

&lt;p&gt;查看java是否安装配置成功，运行java -version&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java version &quot;1.8.0_91&quot;
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置jre路径：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/java.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;maven&quot;&gt;安装maven&lt;/h3&gt;

&lt;p&gt;下载apache-maven-3.3.9-bin.tar.gz安装包，解压即可使用。&lt;/p&gt;

&lt;p&gt;打开.bash_profile，配置maven环境变量：MAVEN_HOME&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;M3_HOME=/Users/test/app/maven3.3.9
PATH=$JAVA_HOME/bin:$M3_HOME/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改完成后，不要忘记运行source .bash_profile，使其生效&lt;/p&gt;

&lt;p&gt;接下来在maven根目录下创建本地仓库目录：repo，同时打开maven下的conf/settings.xml，修改本地仓库路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;localRepository&amp;gt;/Users/test/app/maven3.3.9/repo&amp;lt;/localRepository&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭保存&lt;/p&gt;

&lt;p&gt;然后再eclipse中配置maven路径，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/maven.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置settings.xml文件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/maven2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此maven配置完成。&lt;/p&gt;

&lt;h3 id=&quot;tomcat&quot;&gt;安装tomcat&lt;/h3&gt;

&lt;p&gt;下载apache-tomcat-8.0.33.tar.gz安装包，解压即可使用&lt;/p&gt;

&lt;p&gt;打开eclipse配置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/tomcat.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击finish，配置完成。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>查看Apache的connection数及time_wait过多问题解决</title>
   <link href="http://username.github.io/2016/10/11/apacheconnection"/>
   <updated>2016-10-11T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/10/11/apacheconnection</id>
   <content type="html">
&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;下面介绍一下查看Apache的连接数和当前的连接数以及IP访问次数的常用命令。&lt;/p&gt;

&lt;p&gt;查看了连接数和当前的连接数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;netstat -ant | grep $ip:80 | wc -l 
netstat -ant | grep $ip:80 | grep EST | wc -l 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看IP访问次数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;netstat -nat|grep &quot;:80&quot;|awk &#39;{print $5}&#39; |awk -F: &#39;{print $1}&#39; | sort| uniq -c|sort -n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看当前连接情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39; 
watch &quot;netstat -n | awk &#39;/^tcp/ {++S[\$NF]} END {for(a in S) print a, S[a]}&#39;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SYN_RECV 30           #表示正在等待处理的请求数；
ESTABLISHED 1597      #表示正常数据传输状态；
FIN_WAIT1 51          #表示server端主动要求关闭tcp连接；
FIN_WAIT2 504         #表示客户端中断连接；
TIME_WAIT 1057        #表示处理完毕，等待超时结束的请求数；
LAST_ACK 5            #关闭一个TCP连接需要从两个方向上分别进行关闭，双方都是通过发送FIN来表示单方向数据的关闭，当通信双方发送了最后一个FIN的时候，发送方此时处于LAST_ACK状态，当发送方收到对方的确认（Fin的Ack确认）后才真正关闭整个TCP连接；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/connection.gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一般不到万不得已的情况也不会去查看网络状态，如果服务器出了异常，百分之八九十都是下面两种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务器保持了大量TIME_WAIT状态&lt;/li&gt;
  &lt;li&gt;服务器保持了大量CLOSE_WAIT状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，tomcat崩溃。。。&lt;/p&gt;

&lt;h2 id=&quot;timewait&quot;&gt;大量time_wait问题解决&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;apache参数优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果正在使用apache web服务器，可以从两个方面调整参数：&lt;/p&gt;

&lt;p&gt;1.keepalive关闭&lt;/p&gt;

&lt;p&gt;KeepAlive配置的含义：对于HTTP/1.1的客户端来说，将会尽量的保持客户的HTTP连接，通过一个连接传送多份HTTP请求响应。这样对于客户端来说，可以提高50%左右的响应时间，而于服务器端来说则降低了更多个连接的开销。不过这个依赖于客户端是否想保持连接。IE默认是保持连接的，当你打开100个图片的网站时，IE有可能只打开2个连接，通过这两个连接传送数据，而不是开100个连接。&lt;/p&gt;

&lt;p&gt;在 Apache 服务器中，KeepAlive 是一个布尔值，On 代表打开，Off 代表关闭，这个指令在其他众多的 HTTPD 服务器中都是存在的。&lt;/p&gt;

&lt;p&gt;KeepAliveTimeout 为持久连接保持的时间，也就是说，在这此连接结束后开始计时，多长时间内没有重新发送HTTP请求，就断掉连接。默认设置为5秒，这个值可以大点，但不能太大，否则会出现同时等候过多连接，导致多的内存被占用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;修改...apache/conf/extra/httpd-default.conf
#
# KeepAlive: Whether or not to allow persistent connections (more than
# one request per connection). Set to &quot;Off&quot; to deactivate.
#
KeepAlive On
#
# MaxKeepAliveRequests: The maximum number of requests to allow
# during a persistent connection. Set to 0 to allow an unlimited amount.
# We recommend you leave this number high, for maximum performance.
#
MaxKeepAliveRequests 100
#
# KeepAliveTimeout: Number of seconds to wait for the next request from the
# same client on the same connection.
#
KeepAliveTimeout 5 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.mpm参数调整&lt;/p&gt;

&lt;p&gt;此处可以参考&lt;a href=&quot;http://blog.hugo.gift/2016/06/12/apache&quot;&gt;apache mpm详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核参数调整&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;查看当前系统下所有连接状态的数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#netstat -n|awk &#39;/^tcp/{++S[$NF]}END{for (key in S) print key,S[key]}&#39;
TIME_WAIT 286
FIN_WAIT1 5
FIN_WAIT2 6
ESTABLISHED 269
SYN_RECV 5
CLOSING 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如发现系统存在大量TIME_WAIT状态的连接，通过调整内核参数解决：
编辑文件/etc/sysctl.conf，加入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行 /sbin/sysctl -p 让参数生效。&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_fin_timeout = 30 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。&lt;/p&gt;

&lt;p&gt;其它参数说明：&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_keepalive_time = 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。&lt;/p&gt;

&lt;p&gt;net.ipv4.ip_local_port_range = 1024 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_max_tw_buckets = 5000 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
默 认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。&lt;/p&gt;

&lt;p&gt;注:&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_tw_reuse = 1&lt;/p&gt;

&lt;p&gt;net.ipv4.tcp_tw_recycle = 1&lt;/p&gt;

&lt;p&gt;设置这两个参数： reuse是表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接； recyse是加速TIME-WAIT sockets回收&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;max user processes调整&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过ulimit -a查看当前账号(work)的参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 515225
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 65536
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 10240
cpu time               (seconds, -t) unlimited
max user processes              (-u) 30720
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 /etc/security/limits.d/90-nproc.conf(或/etc/security/limits.conf)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#&amp;lt;domain&amp;gt;      &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;         &amp;lt;value&amp;gt;
*               soft    nproc           4096
root            soft    nproc          unlimited

#Where:
#&amp;lt;domain&amp;gt; can be:
#        - an user name
#        - a group name, with @group syntax
#        - the wildcard *, for default entry
#        - the wildcard %, can be also used with %group syntax,
#                 for maxlogin limit
#
#&amp;lt;type&amp;gt; can have the two values:
#        - &quot;soft&quot; for enforcing the soft limits
#        - &quot;hard&quot; for enforcing hard limits
#
#&amp;lt;item&amp;gt; can be one of the following:
#        - core - limits the core file size (KB)
#        - data - max data size (KB)
#        - fsize - maximum filesize (KB)
#        - memlock - max locked-in-memory address space (KB)
#        - nofile - max number of open files
#        - rss - max resident set size (KB)
#        - stack - max stack size (KB)
#        - cpu - max CPU time (MIN)
#        - nproc - max number of processes
#        - as - address space limit (KB)
#        - maxlogins - max number of logins for this user
#        - maxsyslogins - max number of logins on the system
#        - priority - the priority to run user process with
#        - locks - max number of file locks the user can hold
#        - sigpending - max number of pending signals
#        - msgqueue - max memory used by POSIX message queues (bytes)
#        - nice - max nice priority allowed to raise to values: [-20, 19]
#        - rtprio - max realtime priority
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注： 使用 ulimit -u 4096 修改max user processes的值，但是只能在当前终端的这个session里面生效，重新登录后仍然是使用系统默认值。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache的代理指令</title>
   <link href="http://username.github.io/2016/10/11/apache"/>
   <updated>2016-10-11T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/10/11/apache</id>
   <content type="html">
&lt;p&gt;Apache代理分为正向代理和反向代理，开启apache代理模块需要在httpd.conf中配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LoadModule proxy_module       modules/mod_proxy.so
LoadModule proxy_http_module  modules/mod_proxy_http.so
LoadModule proxy_ftp_module   modules/mod_proxy_ftp.so
LoadModule proxy_ajp_module   modules/mod_proxy_ajp.so
LoadModule proxy_balancer_module modules/mod_proxy_balancer.so
LoadModule proxy_connect_module modules/mod_proxy_connect.so
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;正向代理配置&lt;/h3&gt;

&lt;p&gt;需要需改的配置文件是httpd-vhosts.conf，使用的代理命令是ProxyRequests和ProxyVia。正向代理配置场景如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerAdmin test@gmail.com
    DocumentRoot &quot;D:/www/test&quot;
    ServerName www.test.com
    ServerAlias test.com
    ErrorLog &quot;logs/test.com-error.log&quot;
    CustomLog &quot;logs/test.com-access.log&quot; common    
    Alias /sublook &quot;D:/www/test/look/sublook/&quot;
    &amp;lt;Directory &quot;D:/www/test&quot;&amp;gt;
        Options FollowSymLinks
        AllowOverride All
        Order allow,deny
        Allow from all
    &amp;lt;/Directory&amp;gt;
    #正向代理设置
    ProxyRequests On
    ProxyVia On
    #用来控制谁可以访问你的代理
    &amp;lt;Proxy *&amp;gt;
        Order deny,allow
        Deny from all
        Allow from 127.0.0.1
    &amp;lt;/Proxy&amp;gt;
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是对正向代理那块配置的说明：&lt;/p&gt;

&lt;p&gt;ProxyRequests On：开启Apache正向代理&lt;/p&gt;

&lt;p&gt;ProxyVia On：控制位于代理服务器链中的代理请求的流向&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果设置为默认值Off ，将不会采取特殊的处理。如果一个请求或应答包含”Via:”头，将不进行任何修改而直接通过。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果设置为On每个请求和应答都会对应当前主机得到一个”Via:”头。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果设置为Full ，每个产生的”Via:”头中都会额外加入Apache服务器的版本，以”Via:”注释域出现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果设置为Block ，每个代理请求中的所有”Via:”头行都将被删除。且不会产生新的”Via:”头。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;正向代理测试&lt;/h3&gt;

&lt;p&gt;浏览器设置（以FireFox为例）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/proxy1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;访问 www.sina.com，观察HTTP请求Response：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/proxy2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，Via：www.test.com，正向代理成功了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;反向代理配置&lt;/h3&gt;

&lt;p&gt;需要需改的配置文件是httpd-vhosts.conf，使用的代理命令是ProxyPass和ProxyPassReverse。正向代理配置场景如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerAdmin test@gmail.com
    DocumentRoot &quot;D:/www/test&quot;
    ServerName www.test.com
    ServerAlias test.com
    ErrorLog &quot;logs/test.com-error.log&quot;
    CustomLog &quot;logs/test.com-access.log&quot; common    
    Alias /sublook &quot;D:/www/test/look/sublook/&quot;
    &amp;lt;Directory &quot;D:/www/test&quot;&amp;gt;
        Options FollowSymLinks
        AllowOverride All
        Order allow,deny
        Allow from all
    &amp;lt;/Directory&amp;gt;
    #反向代理设置
    ProxyPass /proxy http://www.proxypass.com/proxy
    ProxyPassReverse /proxy http://www.proxypass.com/proxy
&amp;lt;/VirtualHost&amp;gt;
&amp;lt;VirtualHost *:80&amp;gt;
    ServerAdmin test@gmail.com
    DocumentRoot &quot;D:/www/proxypass&quot;
    ServerName www.proxypass.com
    ServerAlias proxypass.com
    &amp;lt;Directory &quot;D:/www/proxypass&quot;&amp;gt;
        Options FollowSymLinks
        AllowOverride All
        Order allow,deny
        Allow from all
    &amp;lt;/Directory&amp;gt;
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProxyPass /proxy http://www.proxypass.com/proxy : 将 www.test.com/proxy 域下的所有请求转发给 www.proxypass.com/proxy 代理，例如 www.test.com/proxy/login.php 会交给 www.proxypass.com/proxy/login.php 代理&lt;/p&gt;

&lt;p&gt;ProxyPassReverse /proxy http://www.proxypass.com/proxy ：
　　　　　　 
www.proxypass.com/proxy/login.php 中有如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    header(&#39;Location: http://www.proxypass.com/proxy/result.php&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ProxyPass：&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;语法：ProxyPass [path] !&lt;/td&gt;
          &lt;td&gt;url&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;它主要是用作URL前缀匹配，不能有正则表达式，它里面配置的Path实际上是一个虚拟的路径，在反向代理到后端的url后，path是不会带过去的，使用示例：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;    ProxyPass /images/ !
    这个示例表示，/images/的请求不被转发。
    ProxyPass /mirror/foo/ http://backend.example.com/
    我们假设当前的服务地址是http://example.com/，如果我们做下面这样的请求：
    http://example.com/mirror/foo/bar, 那将被转成内部请求：
    http://backend.example.com/bar
    注：配置的时候，不需要被转发的请求，要配置在需要被转发的请求前面。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ProxyPassReverse&lt;/p&gt;

    &lt;p&gt;语法：ProxyPassReverse [路径] url&lt;/p&gt;

    &lt;p&gt;它一般和ProxyPass指令配合使用，此指令使Apache调整HTTP重定向应答中Location,       Content-Location, URI头里的URL，这样可以避免在Apache作为反向代理使用时，。后端服务器的HTTP重定向造成的绕过反向代理的问题。参看下面的示例：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;    ProxyPass /example http://www.example.com/
    ProxyPassReverse /example http://www.example.com/
    ProxyPassReverse的作用就是反向代理，如果没有加这样的反向代理设置的情况下，访问   http://www.test.com/example/a，如果www.example.com对请求进行了redirect至http://www.example.com/b，那么，客户端就会绕过反向代理，进而访问http://www.test.com/example/b。如果设置了反向代理，则会在转交HTTP重定向应答到客户端之前调整它为http://www.test.com/example/a/b，即是在原请求之后追加上了redirect的路径。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ProxyPassMatch&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;语法：ProxyPassMatch [regex] !&lt;/td&gt;
          &lt;td&gt;url&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;这个实际上是url正则匹配，而不是简单的前缀匹配，匹配上的regex部分是会带到后端的url的，这个是与ProxyPass不同的。使用示例：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;    1、ProxyPassMatch ^/images !
       这个示例表示对/images的请求，都不会被转发。
    2、ProxyPassMatch ^(/.*\.gif)$ http://backend.example.com$1
       这个示例表示对所有gif图片的请求，都被会转到后端，如此时请求http://example.com/foo/bar.gif，那内部将会转换为这样的请求http://backend.example.com/foo/bar.gif。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;反向代理测试&lt;/h3&gt;

&lt;p&gt;访问 www.test.com/proxy/login.php&lt;/p&gt;

&lt;p&gt;Apache将请求交给 www.proxypass.com/proxy/login.php 代理，HTTP请求如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/proxy3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以发现其实Request中的请求还是 www.test.com 的，但是它确实是由 www.proxypass.com 来处理的&lt;/p&gt;

&lt;p&gt;proxypass.com/proxy/login.php 重定向到 proxypass.com/proxy/result.php&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/proxy4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也可以看到请求依然是 www.test.com/proxy/result.php&lt;/p&gt;

&lt;p&gt;因为配置了ProxyPassReverse后，proxypass.com/proxy/login.php 在重定向到 proxypass.com/proxy/result.php 时，Apache会将它调整回 test.com/proxy/result.php , 然后Apache再将 test.com/proxy/result.php 代理给 proxypass.com/proxy/result.php，所以说配置了 ProxyPassReverse 后，即使 proxypass.com/proxy 下的程序有重定向到其他 proxypss.com/proxy 的文件的（如 login.php 重定向到 result.php），你也不会在请求中发现 proxypass.com 的影子。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CDN技术原理</title>
   <link href="http://username.github.io/2016/10/10/cdn"/>
   <updated>2016-10-10T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/10/10/cdn</id>
   <content type="html">
&lt;h1 id=&quot;cdn&quot;&gt;CDN技术原理&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;CDN的全称Content Delivery Network，(缩写：CDN)即内容分发网络。&lt;/p&gt;

&lt;p&gt;CDN是一个经策略性部署的整体系统，从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均而产生的用户访问网站响应速度慢的根本原因。&lt;/p&gt;

&lt;p&gt;CDN目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，解决Internet 网络拥塞状况，提高用户访问网站的响应速度。&lt;/p&gt;

&lt;h2 id=&quot;cdn-1&quot;&gt;CDN组成部分&lt;/h2&gt;

&lt;p&gt;CDN是一种组合技术，其中包括源站、缓存服务器、智能DNS、客户端等几个重要部分。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;源站&lt;/h3&gt;

&lt;p&gt;源站指发布内容的原始站点。添加、删除和更改网站的文件，都是在源站上进行的；另外缓存服务器所抓取的对象也全部来自于源站。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;缓存服务器&lt;/h3&gt;

&lt;p&gt;缓存服务器是直接提供给用户访问的站点资源，有一台或数台服务器组成；当用户发起访问时，他的访问请求被智能DNS定位到离他较近的缓存服务器。如果用户所请求的内容刚好在缓存里面，则直接把内容返还给用户；如果访问所需的内容没有被缓存，则缓存服务器向邻近的缓存服务器或直接向源站抓取内容，然后再返还给用户。&lt;/p&gt;

&lt;h3 id=&quot;dns&quot;&gt;智能DNS&lt;/h3&gt;

&lt;p&gt;智能DNS是整个CDN技术的核心，它主要根据用户的来源，将其访问请求指向离用户比较近的缓存服务器，如把广州电信的用户请求指向到广州电信IDC机房中的缓存服务器。通过智能DNS解析，让用户访问同服务商下的服务器，消除国内南北网络互相访问慢的问题，达到加速作用。智能DNS的出现，颠覆了传统的一个域名对应一个镜像的做法，让用户更加便捷的去访问网站。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;客户端&lt;/h3&gt;

&lt;p&gt;客户端或称用户端即发起访问的普通用户，一般的访问方式是浏览器。这里就不再做详细说明。&lt;/p&gt;

&lt;h3 id=&quot;cdn-2&quot;&gt;CDN技术实现原理&lt;/h3&gt;

&lt;p&gt;下图为CDN用户访问流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yuzujin/yuzujin.github.com/master/images/cdn.bmp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;用户向浏览器输入www.web.com这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网站的DNS域名解析器设置了CNAME，指向了www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户向该IP节点（CDN服务器）发出请求；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请求结果发给用户。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，这就是CDN的最基本的原理，当然很多细节没有涉及到，比如第1步，首先向本地的DNS服务器请求。第5步，内容淘汰机制（根据TTL）等。但原理大体如此。&lt;/p&gt;

&lt;p&gt;当用户访问加入CDN服务的网站时，域名解析请求将最终交给全局负载均衡DNS进行处理。全局负载均衡DNS通过一组预先定义好的策略，将当时最接近用 户的节点地址提供给用户，使用户能够得到快速的服务。同时，它还与分布在世界各地的所有CDNC节点保持通信，搜集各节点的通信状态，确保不将用户的请求 分配到不可用的CDN节点上，实际上是通过DNS做全局负载均衡。&lt;/p&gt;

&lt;p&gt;对于普通的Internet用户来讲，每个CDN节点就相当于一个放置在它周围的WEB。通过全局负载均衡DNS的控制，用户的请求被透明地指向离他最近的节点，节点中CDN服务器会像网站的原始服务器一样，响应用户的请求。由于它离用户更近，因而响应时间必然更快。&lt;/p&gt;

&lt;h3 id=&quot;cdn-3&quot;&gt;CDN示例&lt;/h3&gt;

&lt;p&gt;Linux 是开放源代码的免费操作系统，已经成功应用于许多关键领域。Bind是Unix/FreeBSD/Linux等类Unix平台上非常有名DNS服务程序，Internet上超过60％的DNS运行的是bind。Bind的最新版本是9.x，用的比较多的是8.x，bind 9有很多新特性，其中一项是根据用户端源地址对同一域名解析不同的IP地址，有了这种特性，能把用户对同一域名的访问，引导到不同地域节点的服务器上去访问。Squid是Linux等操作系统上有名的Cache引擎，与商业Cache引擎相比，Squid的性能比较低，基本功能工作原理与商业Cache产品是一致的，作为试验，是非常容易配置运行起来。以下简要介绍CDN的配置流程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;要加入CDN服务的网站，需要域名(如www.linuxaid.com.cn, 地址202.99.11.120)解析权提供给CDN运营商，Linuxaid的域名解析记录只要把www主机的A记录改为CNAME并指向cache.cdn.com即可。cache.cdn.com是CDN网络自定义的缓存服务器的标识。在/var/named/linuxaid.com.cn域名解析记录中，由：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
    www             IN      A       202.99.11.120
    改为
    www             IN      CNAME   cache.cdn.com.

&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CDN运营商得到域名解析权以后，得到域名的CNAME记录，指向CDN网络属下缓存服务器的域名，如cache.cdn.com，CDN网络的全局负载均衡DNS，需要把CNAME记录根据策略解析出IP地址，一般是给出就近访问的Cache地址。Bind 9的基本功能可以根据不同的源IP地址段解析对应的IP，实现根据地域就近访问的负载均衡，一般可以通过Bind 9的sortlist选项实现根据用户端IP地址返回最近的节点IP地址，具体的过程为cache.cdn.com设置多个A记录，/var/named/cdn.com 的内容如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;    cache   IN      A               202.93.22.13    ;有多少个CACHE地址
    cache   IN      A               210.21.30.90    ;就有多少个CACHE的A记录
    cache   IN      A               211.99.13.47
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>在aws ec2实例上搭建shadowsocks服务</title>
   <link href="http://username.github.io/2016/10/09/aws-ec2shadowsocks"/>
   <updated>2016-10-09T00:00:00+08:00</updated>
   <id>http://username.github.io/2016/10/09/aws-ec2shadowsocks</id>
   <content type="html">
&lt;p&gt;&lt;strong&gt;Shadowsocks&lt;/strong&gt;一个可穿透防火墙的快速代理。&lt;/p&gt;

&lt;p&gt;github地址：https://github.com/shadowsocks/shadowsocks&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;aws-ec2&quot;&gt;创建aws ec2实例&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;选择t2.micro实例（可以免费使用一年，当然首先你得需要一个aws账号和信用卡信息），镜像选择AMI（实际上是centos系统）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全策略中打开tcp端口（ssh:22、shadowsocks:8388）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;服务端安装&amp;amp;配置&amp;amp;启动&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;yum install -y python-setuptools
easy_install pip
pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置&lt;/p&gt;

    &lt;p&gt;创建配置文件 vi /etc/shadowsocks/config.json&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;{
	&quot;server&quot;:&quot;0.0.0.0&quot;,
	&quot;server_port&quot;:8388,
	&quot;local_address&quot;:&quot;127.0.0.1&quot;,
	&quot;local_port&quot;:1080,
	&quot;password&quot;:&quot;123&quot;,
	&quot;timeout&quot;:300,
	&quot;method&quot;:&quot;aes-256-cfb&quot;,
	&quot;fast_open&quot;:false,
	&quot;workers&quot;: 1
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;各个字段代表的含义如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;server: 服务器监听地址
server_port: 服务器端口
local_address: 本地监听地址
local_port: 本地端口
password: 密码
timeout: 超时时间
method: 加密算法
fast_open: 使用TCP_FASTOPEN，true/false
workers: 工作线程数，Unix/Linux可用
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动
&lt;code&gt;ssserver -c /etc/shadowsocks.json -d start&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;客户端安装配置&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;windows安装shadowsocks客户端&lt;/p&gt;

    &lt;p&gt;-&lt;strong&gt;下载地址&lt;/strong&gt;：https://github.com/shadowsocks/shadowsocks-windows/releases&lt;/p&gt;

    &lt;p&gt;-&lt;strong&gt;服务器地址&lt;/strong&gt;：aws 实例公用ip&lt;/p&gt;

    &lt;p&gt;-&lt;strong&gt;服务器端口&lt;/strong&gt;：ssserver启动的端口&lt;/p&gt;

    &lt;p&gt;-&lt;strong&gt;密码&lt;/strong&gt;：shadowsocks配置的密码(123)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chrome安装switchysharp插件&lt;/p&gt;

    &lt;p&gt;代理协议：socks5 代理服务器：127.0.0.1 代理端口：1080&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;youtube&quot;&gt;访问youtube&lt;/h2&gt;
&lt;p&gt;www.youtube.com 成功。&lt;/p&gt;

&lt;p&gt;参考链接：http://www.cnblogs.com/wwlzz/p/4321998.html&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
